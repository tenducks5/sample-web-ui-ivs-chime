{"ast":null,"code":"\"use strict\"; // Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SDPCandidateType_1 = require(\"./SDPCandidateType\");\n/**\n * Implements [[SDP]]. [[SDP]] also includes a few helper functions for parsing string.\n */\n\n\nvar DefaultSDP =\n/** @class */\nfunction () {\n  function DefaultSDP(sdp) {\n    this.sdp = sdp;\n  }\n\n  DefaultSDP.prototype.clone = function () {\n    return new DefaultSDP(this.sdp);\n  };\n\n  DefaultSDP.isRTPCandidate = function (candidate) {\n    var match = /candidate[:](\\S+) (\\d+)/g.exec(candidate);\n\n    if (match === null || match[2] !== '1') {\n      return false;\n    }\n\n    return true;\n  };\n\n  DefaultSDP.linesToSDP = function (lines) {\n    return new DefaultSDP(lines.join(DefaultSDP.CRLF));\n  };\n\n  DefaultSDP.candidateTypeFromString = function (candidateType) {\n    switch (candidateType) {\n      case SDPCandidateType_1.default.Host:\n        return SDPCandidateType_1.default.Host;\n\n      case SDPCandidateType_1.default.ServerReflexive:\n        return SDPCandidateType_1.default.ServerReflexive;\n\n      case SDPCandidateType_1.default.PeerReflexive:\n        return SDPCandidateType_1.default.PeerReflexive;\n\n      case SDPCandidateType_1.default.Relay:\n        return SDPCandidateType_1.default.Relay;\n    }\n\n    return null;\n  };\n\n  DefaultSDP.candidateType = function (sdpLine) {\n    var match = /a[=]candidate[:].* typ ([a-z]+) /g.exec(sdpLine);\n\n    if (match === null) {\n      return null;\n    }\n\n    return DefaultSDP.candidateTypeFromString(match[1]);\n  };\n\n  DefaultSDP.splitLines = function (blob) {\n    return blob.trim().split('\\n').map(function (line) {\n      return line.trim();\n    });\n  };\n\n  DefaultSDP.splitSections = function (sdp) {\n    // each section starts with \"m=\"\n    var sections = sdp.split('\\nm=');\n    return sections.map(function (section, index) {\n      return (index > 0 ? 'm=' + section : section).trim() + DefaultSDP.CRLF;\n    });\n  };\n\n  DefaultSDP.findActiveCameraSection = function (sections) {\n    var e_1, _a;\n\n    var cameraLineIndex = 0;\n    var hasCamera = false;\n\n    try {\n      for (var sections_1 = __values(sections), sections_1_1 = sections_1.next(); !sections_1_1.done; sections_1_1 = sections_1.next()) {\n        var sec = sections_1_1.value;\n\n        if (/^m=video/.test(sec)) {\n          if (sec.indexOf('sendrecv') > -1) {\n            hasCamera = true;\n            break;\n          }\n        }\n\n        cameraLineIndex++;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (sections_1_1 && !sections_1_1.done && (_a = sections_1.return)) _a.call(sections_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (hasCamera === false) {\n      cameraLineIndex = -1;\n    }\n\n    return cameraLineIndex;\n  };\n\n  DefaultSDP.parseSSRCMedia = function (ssrcMediaAttributeLine) {\n    var separator = ssrcMediaAttributeLine.indexOf(' ');\n    var ssrc = 0;\n    var attribute = '';\n    var value = '';\n    ssrc = DefaultSDP.extractSSRCFromAttributeLine(ssrcMediaAttributeLine);\n    var secondColon = ssrcMediaAttributeLine.indexOf(':', separator);\n\n    if (secondColon > -1) {\n      attribute = ssrcMediaAttributeLine.substr(separator + 1, secondColon - separator - 1);\n      value = ssrcMediaAttributeLine.substr(secondColon + 1);\n    } else {\n      attribute = ssrcMediaAttributeLine.substr(separator + 1);\n    }\n\n    return [ssrc, attribute, value];\n  }; // a=ssrc-group:<semantics> <ssrc-id> ...\n\n\n  DefaultSDP.extractSSRCsFromFIDGroupLine = function (figGroupLine) {\n    var ssrcStringMatch = /^a=ssrc-group:FID\\s(.+)/.exec(figGroupLine);\n    return ssrcStringMatch[1];\n  }; // a=ssrc:<ssrc-id> <attribute> or a=ssrc:<ssrc-id> <attribute>:<value>, ssrc-id is a 32bit integer\n\n\n  DefaultSDP.extractSSRCFromAttributeLine = function (ssrcMediaAttributeLine) {\n    var ssrcStringMatch = /^a=ssrc:([0-9]+)\\s/.exec(ssrcMediaAttributeLine);\n\n    if (ssrcStringMatch === null) {\n      return 0;\n    }\n\n    return parseInt(ssrcStringMatch[1], 10);\n  };\n\n  DefaultSDP.matchPrefix = function (blob, prefix) {\n    return DefaultSDP.splitLines(blob).filter(function (line) {\n      return line.indexOf(prefix) === 0;\n    });\n  };\n\n  DefaultSDP.prototype.lines = function () {\n    return this.sdp.split(DefaultSDP.CRLF);\n  };\n\n  DefaultSDP.prototype.hasVideo = function () {\n    return /^m=video/gm.exec(this.sdp) !== null;\n  };\n\n  DefaultSDP.prototype.hasCandidates = function () {\n    var match = /a[=]candidate[:]/g.exec(this.sdp);\n\n    if (match === null) {\n      return false;\n    }\n\n    return true;\n  };\n\n  DefaultSDP.prototype.hasCandidatesForAllMLines = function () {\n    var isAnyCLineUsingLocalHost = this.sdp.indexOf('c=IN IP4 0.0.0.0') > -1;\n    var mLinesHaveCandidates = !isAnyCLineUsingLocalHost;\n    return mLinesHaveCandidates;\n  };\n\n  DefaultSDP.prototype.withBundleAudioVideo = function () {\n    var e_2, _a;\n\n    var srcLines = this.lines();\n    var dstLines = [];\n\n    try {\n      for (var srcLines_1 = __values(srcLines), srcLines_1_1 = srcLines_1.next(); !srcLines_1_1.done; srcLines_1_1 = srcLines_1.next()) {\n        var line = srcLines_1_1.value;\n        var mod = line.replace(/^a=group:BUNDLE audio$/, 'a=group:BUNDLE audio video');\n\n        if (mod !== line) {\n          dstLines.push(mod);\n          continue;\n        }\n\n        dstLines.push(line);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (srcLines_1_1 && !srcLines_1_1.done && (_a = srcLines_1.return)) _a.call(srcLines_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  };\n\n  DefaultSDP.prototype.copyVideo = function (otherSDP) {\n    var e_3, _a;\n\n    var otherLines = otherSDP.split(DefaultSDP.CRLF);\n    var dstLines = DefaultSDP.splitLines(this.sdp);\n    var inVideoMedia = false;\n\n    try {\n      for (var otherLines_1 = __values(otherLines), otherLines_1_1 = otherLines_1.next(); !otherLines_1_1.done; otherLines_1_1 = otherLines_1.next()) {\n        var line = otherLines_1_1.value;\n\n        if (/^m=video/.test(line)) {\n          inVideoMedia = true;\n        } else if (/^m=/.test(line)) {\n          inVideoMedia = false;\n        }\n\n        if (inVideoMedia) {\n          dstLines.push(line);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (otherLines_1_1 && !otherLines_1_1.done && (_a = otherLines_1.return)) _a.call(otherLines_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  };\n\n  DefaultSDP.prototype.withoutCandidateType = function (candidateTypeToExclude) {\n    return DefaultSDP.linesToSDP(this.lines().filter(function (line) {\n      return DefaultSDP.candidateType(line) !== candidateTypeToExclude;\n    }));\n  };\n\n  DefaultSDP.prototype.withoutServerReflexiveCandidates = function () {\n    return this.withoutCandidateType(SDPCandidateType_1.default.ServerReflexive);\n  };\n\n  DefaultSDP.prototype.withBandwidthRestriction = function (maxBitrateKbps, isUnifiedPlan) {\n    var e_4, _a;\n\n    var srcLines = this.lines();\n    var dstLines = [];\n\n    try {\n      for (var srcLines_2 = __values(srcLines), srcLines_2_1 = srcLines_2.next(); !srcLines_2_1.done; srcLines_2_1 = srcLines_2.next()) {\n        var line = srcLines_2_1.value;\n        dstLines.push(line);\n\n        if (/^m=video/.test(line)) {\n          if (isUnifiedPlan) {\n            dstLines.push(\"b=TIAS:\" + maxBitrateKbps * 1000);\n          } else {\n            dstLines.push(\"b=AS:\" + maxBitrateKbps);\n          }\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (srcLines_2_1 && !srcLines_2_1.done && (_a = srcLines_2.return)) _a.call(srcLines_2);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return DefaultSDP.linesToSDP(dstLines);\n  }; // TODO: will remove this soon.\n\n\n  DefaultSDP.prototype.withUnifiedPlanFormat = function () {\n    var originalSdp = this.sdp;\n\n    if (originalSdp.includes('mozilla')) {\n      return this.clone();\n    } else {\n      originalSdp = originalSdp.replace('o=-', 'o=mozilla-chrome');\n    }\n\n    return new DefaultSDP(originalSdp);\n  };\n\n  DefaultSDP.prototype.preferH264IfExists = function () {\n    var srcSDP = this.sdp;\n    var sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    var newSections = [];\n\n    var _loop_1 = function (i) {\n      if (/^m=video/.test(sections[i])) {\n        var lines = DefaultSDP.splitLines(sections[i]);\n        var payloadTypeForVP8_1 = 0;\n        var payloadTypeForH264_1 = 0;\n        lines.forEach(function (attribute) {\n          if (/^a=rtpmap:/.test(attribute)) {\n            var payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(attribute);\n\n            if (attribute.toLowerCase().includes('vp8')) {\n              payloadTypeForVP8_1 = parseInt(payloadMatch[1], 10);\n            } else if (attribute.toLowerCase().includes('h264')) {\n              payloadTypeForH264_1 = parseInt(payloadMatch[1], 10);\n            }\n          }\n        }); // m=video 9 UDP/+++ <payload>\n\n        if (payloadTypeForVP8_1 !== 0 && payloadTypeForH264_1 !== 0) {\n          var mline = lines[0].split(' ');\n          var indexForVP8 = -1;\n          var indexForH264 = -1;\n\n          for (var i_1 = 3; i_1 < mline.length; i_1++) {\n            var payload = parseInt(mline[i_1], 10);\n\n            if (payload === payloadTypeForVP8_1) {\n              indexForVP8 = i_1;\n            } else if (payload === payloadTypeForH264_1) {\n              indexForH264 = i_1;\n            }\n          }\n\n          if (indexForVP8 < indexForH264) {\n            mline[indexForVP8] = payloadTypeForH264_1.toString();\n            mline[indexForH264] = payloadTypeForVP8_1.toString();\n          }\n\n          lines[0] = mline.join(' ');\n        }\n\n        sections[i] = lines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF; // since there is only H264 or VP8, we don't switch payload places\n      }\n\n      newSections.push(sections[i]);\n    };\n\n    for (var i = 0; i < sections.length; i++) {\n      _loop_1(i);\n    }\n\n    var newSdp = newSections.join('');\n    return new DefaultSDP(newSdp);\n  };\n\n  DefaultSDP.prototype.withOldFashionedMungingSimulcast = function (videoSimulcastLayerCount) {\n    if (videoSimulcastLayerCount < 2) {\n      return this.clone();\n    }\n\n    var srcSDP = this.sdp;\n    var sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    var cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n\n    if (cameraLineIndex === -1) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    var cname = '';\n    var msid = '';\n    DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc:').forEach(function (line) {\n      var ssrcAttrTuple = DefaultSDP.parseSSRCMedia(line);\n\n      if (ssrcAttrTuple[1] === 'cname') {\n        cname = ssrcAttrTuple[2];\n      } else if (ssrcAttrTuple[1] === 'msid') {\n        msid = ssrcAttrTuple[2];\n      }\n    });\n    var fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n\n    if (cname === '' || msid === '' || fidGroupMatch.length < 1) {\n      return new DefaultSDP(this.sdp);\n    }\n\n    var fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n    var cameraSectionLines = sections[cameraLineIndex].trim().split(DefaultSDP.CRLF).filter(function (line) {\n      return line.indexOf('a=ssrc:') !== 0 && line.indexOf('a=ssrc-group:') !== 0;\n    });\n    var simulcastSSRCs = [];\n\n    var _a = __read(fidGroup.split(' ').map(function (ssrc) {\n      return parseInt(ssrc, 10);\n    }), 2),\n        videoSSRC1 = _a[0],\n        rtxSSRC1 = _a[1];\n\n    var videoSSRC = videoSSRC1;\n    var rtxSSRC = rtxSSRC1;\n\n    for (var i = 0; i < videoSimulcastLayerCount; i++) {\n      cameraSectionLines.push('a=ssrc:' + videoSSRC + ' cname:' + cname);\n      cameraSectionLines.push('a=ssrc:' + videoSSRC + ' msid:' + msid);\n      cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' cname:' + cname);\n      cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' msid:' + msid);\n      cameraSectionLines.push('a=ssrc-group:FID ' + videoSSRC + ' ' + rtxSSRC);\n      simulcastSSRCs.push(videoSSRC);\n      videoSSRC = videoSSRC + 1;\n      rtxSSRC = videoSSRC + 1;\n    }\n\n    cameraSectionLines.push('a=ssrc-group:SIM ' + simulcastSSRCs.join(' '));\n    sections[cameraLineIndex] = cameraSectionLines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n    var newSDP = sections.join('');\n    return new DefaultSDP(newSDP);\n  };\n\n  DefaultSDP.prototype.ssrcForVideoSendingSection = function () {\n    var srcSDP = this.sdp;\n    var sections = DefaultSDP.splitSections(srcSDP);\n\n    if (sections.length < 2) {\n      return '';\n    }\n\n    var cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n\n    if (cameraLineIndex === -1) {\n      return '';\n    } // TODO: match for Firefox. Currently all failures are not Firefox induced.\n\n\n    var fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n\n    if (fidGroupMatch.length < 1) {\n      return '';\n    }\n\n    var fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n\n    var _a = __read(fidGroup.split(' ').map(function (ssrc) {\n      return parseInt(ssrc, 10);\n    }), 1),\n        videoSSRC1 = _a[0];\n\n    return videoSSRC1.toString();\n  };\n\n  DefaultSDP.prototype.videoSendSectionHasDifferentSSRC = function (prevSdp) {\n    var ssrc1 = this.ssrcForVideoSendingSection();\n    var ssrc2 = prevSdp.ssrcForVideoSendingSection();\n\n    if (ssrc1 === '' || ssrc2 === '') {\n      return false;\n    }\n\n    var ssrc1InNumber = parseInt(ssrc1, 10);\n    var ssrc2InNumber = parseInt(ssrc2, 10);\n\n    if (ssrc1InNumber === ssrc2InNumber) {\n      return false;\n    }\n\n    return true;\n  };\n\n  DefaultSDP.CRLF = '\\r\\n';\n  return DefaultSDP;\n}();\n\nexports.default = DefaultSDP;","map":{"version":3,"sources":["../../src/sdp/DefaultSDP.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2019-2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SDPCandidateType_1 = require(\"./SDPCandidateType\");\n/**\n * Implements [[SDP]]. [[SDP]] also includes a few helper functions for parsing string.\n */\nvar DefaultSDP = /** @class */ (function () {\n    function DefaultSDP(sdp) {\n        this.sdp = sdp;\n    }\n    DefaultSDP.prototype.clone = function () {\n        return new DefaultSDP(this.sdp);\n    };\n    DefaultSDP.isRTPCandidate = function (candidate) {\n        var match = /candidate[:](\\S+) (\\d+)/g.exec(candidate);\n        if (match === null || match[2] !== '1') {\n            return false;\n        }\n        return true;\n    };\n    DefaultSDP.linesToSDP = function (lines) {\n        return new DefaultSDP(lines.join(DefaultSDP.CRLF));\n    };\n    DefaultSDP.candidateTypeFromString = function (candidateType) {\n        switch (candidateType) {\n            case SDPCandidateType_1.default.Host:\n                return SDPCandidateType_1.default.Host;\n            case SDPCandidateType_1.default.ServerReflexive:\n                return SDPCandidateType_1.default.ServerReflexive;\n            case SDPCandidateType_1.default.PeerReflexive:\n                return SDPCandidateType_1.default.PeerReflexive;\n            case SDPCandidateType_1.default.Relay:\n                return SDPCandidateType_1.default.Relay;\n        }\n        return null;\n    };\n    DefaultSDP.candidateType = function (sdpLine) {\n        var match = /a[=]candidate[:].* typ ([a-z]+) /g.exec(sdpLine);\n        if (match === null) {\n            return null;\n        }\n        return DefaultSDP.candidateTypeFromString(match[1]);\n    };\n    DefaultSDP.splitLines = function (blob) {\n        return blob\n            .trim()\n            .split('\\n')\n            .map(function (line) {\n            return line.trim();\n        });\n    };\n    DefaultSDP.splitSections = function (sdp) {\n        // each section starts with \"m=\"\n        var sections = sdp.split('\\nm=');\n        return sections.map(function (section, index) {\n            return (index > 0 ? 'm=' + section : section).trim() + DefaultSDP.CRLF;\n        });\n    };\n    DefaultSDP.findActiveCameraSection = function (sections) {\n        var e_1, _a;\n        var cameraLineIndex = 0;\n        var hasCamera = false;\n        try {\n            for (var sections_1 = __values(sections), sections_1_1 = sections_1.next(); !sections_1_1.done; sections_1_1 = sections_1.next()) {\n                var sec = sections_1_1.value;\n                if (/^m=video/.test(sec)) {\n                    if (sec.indexOf('sendrecv') > -1) {\n                        hasCamera = true;\n                        break;\n                    }\n                }\n                cameraLineIndex++;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (sections_1_1 && !sections_1_1.done && (_a = sections_1.return)) _a.call(sections_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (hasCamera === false) {\n            cameraLineIndex = -1;\n        }\n        return cameraLineIndex;\n    };\n    DefaultSDP.parseSSRCMedia = function (ssrcMediaAttributeLine) {\n        var separator = ssrcMediaAttributeLine.indexOf(' ');\n        var ssrc = 0;\n        var attribute = '';\n        var value = '';\n        ssrc = DefaultSDP.extractSSRCFromAttributeLine(ssrcMediaAttributeLine);\n        var secondColon = ssrcMediaAttributeLine.indexOf(':', separator);\n        if (secondColon > -1) {\n            attribute = ssrcMediaAttributeLine.substr(separator + 1, secondColon - separator - 1);\n            value = ssrcMediaAttributeLine.substr(secondColon + 1);\n        }\n        else {\n            attribute = ssrcMediaAttributeLine.substr(separator + 1);\n        }\n        return [ssrc, attribute, value];\n    };\n    // a=ssrc-group:<semantics> <ssrc-id> ...\n    DefaultSDP.extractSSRCsFromFIDGroupLine = function (figGroupLine) {\n        var ssrcStringMatch = /^a=ssrc-group:FID\\s(.+)/.exec(figGroupLine);\n        return ssrcStringMatch[1];\n    };\n    // a=ssrc:<ssrc-id> <attribute> or a=ssrc:<ssrc-id> <attribute>:<value>, ssrc-id is a 32bit integer\n    DefaultSDP.extractSSRCFromAttributeLine = function (ssrcMediaAttributeLine) {\n        var ssrcStringMatch = /^a=ssrc:([0-9]+)\\s/.exec(ssrcMediaAttributeLine);\n        if (ssrcStringMatch === null) {\n            return 0;\n        }\n        return parseInt(ssrcStringMatch[1], 10);\n    };\n    DefaultSDP.matchPrefix = function (blob, prefix) {\n        return DefaultSDP.splitLines(blob).filter(function (line) {\n            return line.indexOf(prefix) === 0;\n        });\n    };\n    DefaultSDP.prototype.lines = function () {\n        return this.sdp.split(DefaultSDP.CRLF);\n    };\n    DefaultSDP.prototype.hasVideo = function () {\n        return /^m=video/gm.exec(this.sdp) !== null;\n    };\n    DefaultSDP.prototype.hasCandidates = function () {\n        var match = /a[=]candidate[:]/g.exec(this.sdp);\n        if (match === null) {\n            return false;\n        }\n        return true;\n    };\n    DefaultSDP.prototype.hasCandidatesForAllMLines = function () {\n        var isAnyCLineUsingLocalHost = this.sdp.indexOf('c=IN IP4 0.0.0.0') > -1;\n        var mLinesHaveCandidates = !isAnyCLineUsingLocalHost;\n        return mLinesHaveCandidates;\n    };\n    DefaultSDP.prototype.withBundleAudioVideo = function () {\n        var e_2, _a;\n        var srcLines = this.lines();\n        var dstLines = [];\n        try {\n            for (var srcLines_1 = __values(srcLines), srcLines_1_1 = srcLines_1.next(); !srcLines_1_1.done; srcLines_1_1 = srcLines_1.next()) {\n                var line = srcLines_1_1.value;\n                var mod = line.replace(/^a=group:BUNDLE audio$/, 'a=group:BUNDLE audio video');\n                if (mod !== line) {\n                    dstLines.push(mod);\n                    continue;\n                }\n                dstLines.push(line);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (srcLines_1_1 && !srcLines_1_1.done && (_a = srcLines_1.return)) _a.call(srcLines_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    };\n    DefaultSDP.prototype.copyVideo = function (otherSDP) {\n        var e_3, _a;\n        var otherLines = otherSDP.split(DefaultSDP.CRLF);\n        var dstLines = DefaultSDP.splitLines(this.sdp);\n        var inVideoMedia = false;\n        try {\n            for (var otherLines_1 = __values(otherLines), otherLines_1_1 = otherLines_1.next(); !otherLines_1_1.done; otherLines_1_1 = otherLines_1.next()) {\n                var line = otherLines_1_1.value;\n                if (/^m=video/.test(line)) {\n                    inVideoMedia = true;\n                }\n                else if (/^m=/.test(line)) {\n                    inVideoMedia = false;\n                }\n                if (inVideoMedia) {\n                    dstLines.push(line);\n                }\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (otherLines_1_1 && !otherLines_1_1.done && (_a = otherLines_1.return)) _a.call(otherLines_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    };\n    DefaultSDP.prototype.withoutCandidateType = function (candidateTypeToExclude) {\n        return DefaultSDP.linesToSDP(this.lines().filter(function (line) { return DefaultSDP.candidateType(line) !== candidateTypeToExclude; }));\n    };\n    DefaultSDP.prototype.withoutServerReflexiveCandidates = function () {\n        return this.withoutCandidateType(SDPCandidateType_1.default.ServerReflexive);\n    };\n    DefaultSDP.prototype.withBandwidthRestriction = function (maxBitrateKbps, isUnifiedPlan) {\n        var e_4, _a;\n        var srcLines = this.lines();\n        var dstLines = [];\n        try {\n            for (var srcLines_2 = __values(srcLines), srcLines_2_1 = srcLines_2.next(); !srcLines_2_1.done; srcLines_2_1 = srcLines_2.next()) {\n                var line = srcLines_2_1.value;\n                dstLines.push(line);\n                if (/^m=video/.test(line)) {\n                    if (isUnifiedPlan) {\n                        dstLines.push(\"b=TIAS:\" + maxBitrateKbps * 1000);\n                    }\n                    else {\n                        dstLines.push(\"b=AS:\" + maxBitrateKbps);\n                    }\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (srcLines_2_1 && !srcLines_2_1.done && (_a = srcLines_2.return)) _a.call(srcLines_2);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return DefaultSDP.linesToSDP(dstLines);\n    };\n    // TODO: will remove this soon.\n    DefaultSDP.prototype.withUnifiedPlanFormat = function () {\n        var originalSdp = this.sdp;\n        if (originalSdp.includes('mozilla')) {\n            return this.clone();\n        }\n        else {\n            originalSdp = originalSdp.replace('o=-', 'o=mozilla-chrome');\n        }\n        return new DefaultSDP(originalSdp);\n    };\n    DefaultSDP.prototype.preferH264IfExists = function () {\n        var srcSDP = this.sdp;\n        var sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return new DefaultSDP(this.sdp);\n        }\n        var newSections = [];\n        var _loop_1 = function (i) {\n            if (/^m=video/.test(sections[i])) {\n                var lines = DefaultSDP.splitLines(sections[i]);\n                var payloadTypeForVP8_1 = 0;\n                var payloadTypeForH264_1 = 0;\n                lines.forEach(function (attribute) {\n                    if (/^a=rtpmap:/.test(attribute)) {\n                        var payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(attribute);\n                        if (attribute.toLowerCase().includes('vp8')) {\n                            payloadTypeForVP8_1 = parseInt(payloadMatch[1], 10);\n                        }\n                        else if (attribute.toLowerCase().includes('h264')) {\n                            payloadTypeForH264_1 = parseInt(payloadMatch[1], 10);\n                        }\n                    }\n                });\n                // m=video 9 UDP/+++ <payload>\n                if (payloadTypeForVP8_1 !== 0 && payloadTypeForH264_1 !== 0) {\n                    var mline = lines[0].split(' ');\n                    var indexForVP8 = -1;\n                    var indexForH264 = -1;\n                    for (var i_1 = 3; i_1 < mline.length; i_1++) {\n                        var payload = parseInt(mline[i_1], 10);\n                        if (payload === payloadTypeForVP8_1) {\n                            indexForVP8 = i_1;\n                        }\n                        else if (payload === payloadTypeForH264_1) {\n                            indexForH264 = i_1;\n                        }\n                    }\n                    if (indexForVP8 < indexForH264) {\n                        mline[indexForVP8] = payloadTypeForH264_1.toString();\n                        mline[indexForH264] = payloadTypeForVP8_1.toString();\n                    }\n                    lines[0] = mline.join(' ');\n                }\n                sections[i] = lines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n                // since there is only H264 or VP8, we don't switch payload places\n            }\n            newSections.push(sections[i]);\n        };\n        for (var i = 0; i < sections.length; i++) {\n            _loop_1(i);\n        }\n        var newSdp = newSections.join('');\n        return new DefaultSDP(newSdp);\n    };\n    DefaultSDP.prototype.withOldFashionedMungingSimulcast = function (videoSimulcastLayerCount) {\n        if (videoSimulcastLayerCount < 2) {\n            return this.clone();\n        }\n        var srcSDP = this.sdp;\n        var sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return new DefaultSDP(this.sdp);\n        }\n        var cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n        if (cameraLineIndex === -1) {\n            return new DefaultSDP(this.sdp);\n        }\n        var cname = '';\n        var msid = '';\n        DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc:').forEach(function (line) {\n            var ssrcAttrTuple = DefaultSDP.parseSSRCMedia(line);\n            if (ssrcAttrTuple[1] === 'cname') {\n                cname = ssrcAttrTuple[2];\n            }\n            else if (ssrcAttrTuple[1] === 'msid') {\n                msid = ssrcAttrTuple[2];\n            }\n        });\n        var fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n        if (cname === '' || msid === '' || fidGroupMatch.length < 1) {\n            return new DefaultSDP(this.sdp);\n        }\n        var fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n        var cameraSectionLines = sections[cameraLineIndex]\n            .trim()\n            .split(DefaultSDP.CRLF)\n            .filter(function (line) {\n            return line.indexOf('a=ssrc:') !== 0 && line.indexOf('a=ssrc-group:') !== 0;\n        });\n        var simulcastSSRCs = [];\n        var _a = __read(fidGroup.split(' ').map(function (ssrc) { return parseInt(ssrc, 10); }), 2), videoSSRC1 = _a[0], rtxSSRC1 = _a[1];\n        var videoSSRC = videoSSRC1;\n        var rtxSSRC = rtxSSRC1;\n        for (var i = 0; i < videoSimulcastLayerCount; i++) {\n            cameraSectionLines.push('a=ssrc:' + videoSSRC + ' cname:' + cname);\n            cameraSectionLines.push('a=ssrc:' + videoSSRC + ' msid:' + msid);\n            cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' cname:' + cname);\n            cameraSectionLines.push('a=ssrc:' + rtxSSRC + ' msid:' + msid);\n            cameraSectionLines.push('a=ssrc-group:FID ' + videoSSRC + ' ' + rtxSSRC);\n            simulcastSSRCs.push(videoSSRC);\n            videoSSRC = videoSSRC + 1;\n            rtxSSRC = videoSSRC + 1;\n        }\n        cameraSectionLines.push('a=ssrc-group:SIM ' + simulcastSSRCs.join(' '));\n        sections[cameraLineIndex] = cameraSectionLines.join(DefaultSDP.CRLF) + DefaultSDP.CRLF;\n        var newSDP = sections.join('');\n        return new DefaultSDP(newSDP);\n    };\n    DefaultSDP.prototype.ssrcForVideoSendingSection = function () {\n        var srcSDP = this.sdp;\n        var sections = DefaultSDP.splitSections(srcSDP);\n        if (sections.length < 2) {\n            return '';\n        }\n        var cameraLineIndex = DefaultSDP.findActiveCameraSection(sections);\n        if (cameraLineIndex === -1) {\n            return '';\n        }\n        // TODO: match for Firefox. Currently all failures are not Firefox induced.\n        var fidGroupMatch = DefaultSDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n        if (fidGroupMatch.length < 1) {\n            return '';\n        }\n        var fidGroup = DefaultSDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n        var _a = __read(fidGroup.split(' ').map(function (ssrc) { return parseInt(ssrc, 10); }), 1), videoSSRC1 = _a[0];\n        return videoSSRC1.toString();\n    };\n    DefaultSDP.prototype.videoSendSectionHasDifferentSSRC = function (prevSdp) {\n        var ssrc1 = this.ssrcForVideoSendingSection();\n        var ssrc2 = prevSdp.ssrcForVideoSendingSection();\n        if (ssrc1 === '' || ssrc2 === '') {\n            return false;\n        }\n        var ssrc1InNumber = parseInt(ssrc1, 10);\n        var ssrc2InNumber = parseInt(ssrc2, 10);\n        if (ssrc1InNumber === ssrc2InNumber) {\n            return false;\n        }\n        return true;\n    };\n    DefaultSDP.CRLF = '\\r\\n';\n    return DefaultSDP;\n}());\nexports.default = DefaultSDP;\n//# sourceMappingURL=DefaultSDP.js.map"]},"metadata":{},"sourceType":"script"}