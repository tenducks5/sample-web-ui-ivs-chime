{"ast":null,"code":"\"use strict\"; // Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar DragType_1 = require(\"../../dragobserver/DragType\");\n\nvar PresentationPolicy_1 = require(\"./PresentationPolicy\");\n\nvar ScaleToFitPresentationPolicy_1 = require(\"./ScaleToFitPresentationPolicy\");\n\nvar DragAndZoomPresentationPolicy =\n/** @class */\nfunction () {\n  function DragAndZoomPresentationPolicy() {\n    this.calculate = function (state, updateEvent) {\n      var newContentDimensions = DragAndZoomPresentationPolicy.getNewContentDimensions(state.contentPlacement.dimensions, state.sourceDimensions, updateEvent);\n\n      if (DragAndZoomPresentationPolicy.shouldScaleToFit(newContentDimensions, state.viewportDimensions, updateEvent)) {\n        return new ScaleToFitPresentationPolicy_1.default().calculate(state);\n      }\n\n      if (updateEvent && updateEvent.drag && updateEvent.drag.type !== DragType_1.default.END) {\n        // A drag event has occurred, the content placement's translations are dependent on the focus\n        return {\n          dimensions: newContentDimensions,\n          translations: [state.focus.normalizedViewportFocus[0] * state.viewportDimensions[0] - state.focus.normalizedContentFocus[0] * newContentDimensions[0], state.focus.normalizedViewportFocus[1] * state.viewportDimensions[1] - state.focus.normalizedContentFocus[1] * newContentDimensions[1]]\n        };\n      } // Dragging just ended or there's no dragging, center and remove whitespace\n\n\n      return {\n        dimensions: newContentDimensions,\n        translations: [DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim(newContentDimensions[0], state.contentPlacement.translations[0], state.viewportDimensions[0]), DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim(newContentDimensions[1], state.contentPlacement.translations[1], state.viewportDimensions[1])]\n      };\n    };\n  }\n\n  DragAndZoomPresentationPolicy.getNewContentDimensions = function (currentContentDims, sourceDims, updateEvent) {\n    // If a zoom event is present, apply the zoom factor\n    if (updateEvent && updateEvent.zoom && updateEvent.zoom.relativeFactor) {\n      return currentContentDims.map(function (d) {\n        return d * updateEvent.zoom.relativeFactor;\n      });\n    }\n\n    if (updateEvent && updateEvent.zoom && updateEvent.zoom.absoluteFactor) {\n      return sourceDims.map(function (d) {\n        return d * updateEvent.zoom.absoluteFactor;\n      });\n    }\n\n    return currentContentDims;\n  };\n\n  DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim = function (contentDim, translation, viewportDim) {\n    if (contentDim <= viewportDim) {\n      // The content placement's dimension is smaller than the viewport's, center it\n      return viewportDim / 2 - contentDim / 2;\n    }\n\n    if (translation > 0) {\n      // The content placement has a positive translation, make it flush against that border\n      return 0;\n    }\n\n    var right = translation + contentDim;\n\n    if (right < viewportDim) {\n      // The content placement has a positive translation on the other side, make it flush against that border\n      return viewportDim - contentDim;\n    } // The content is zoomed such that there's no whitespace, retain the current translation\n\n\n    return translation;\n  };\n\n  DragAndZoomPresentationPolicy.shouldScaleToFit = function (_a, _b, updateEvent) {\n    var _c = __read(_a, 2),\n        newContentWidth = _c[0],\n        newContentHeight = _c[1];\n\n    var _d = __read(_b, 2),\n        viewportWidth = _d[0],\n        viewportHeight = _d[1]; // Should scale to fit if a reset zoom event occurred or, after applying a zoom event, the content width and height\n    // are smaller than the viewport width and height\n\n\n    return updateEvent && updateEvent.zoom && updateEvent.zoom.type === PresentationPolicy_1.ZoomType.RESET || newContentWidth <= viewportWidth && newContentHeight <= viewportHeight;\n  };\n\n  return DragAndZoomPresentationPolicy;\n}();\n\nexports.default = DragAndZoomPresentationPolicy;","map":{"version":3,"sources":["../../../src/presentation/policy/DragAndZoomPresentationPolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DragType_1 = require(\"../../dragobserver/DragType\");\nvar PresentationPolicy_1 = require(\"./PresentationPolicy\");\nvar ScaleToFitPresentationPolicy_1 = require(\"./ScaleToFitPresentationPolicy\");\nvar DragAndZoomPresentationPolicy = /** @class */ (function () {\n    function DragAndZoomPresentationPolicy() {\n        this.calculate = function (state, updateEvent) {\n            var newContentDimensions = DragAndZoomPresentationPolicy.getNewContentDimensions(state.contentPlacement.dimensions, state.sourceDimensions, updateEvent);\n            if (DragAndZoomPresentationPolicy.shouldScaleToFit(newContentDimensions, state.viewportDimensions, updateEvent)) {\n                return new ScaleToFitPresentationPolicy_1.default().calculate(state);\n            }\n            if (updateEvent && updateEvent.drag && updateEvent.drag.type !== DragType_1.default.END) {\n                // A drag event has occurred, the content placement's translations are dependent on the focus\n                return {\n                    dimensions: newContentDimensions,\n                    translations: [\n                        state.focus.normalizedViewportFocus[0] * state.viewportDimensions[0] -\n                            state.focus.normalizedContentFocus[0] * newContentDimensions[0],\n                        state.focus.normalizedViewportFocus[1] * state.viewportDimensions[1] -\n                            state.focus.normalizedContentFocus[1] * newContentDimensions[1],\n                    ],\n                };\n            }\n            // Dragging just ended or there's no dragging, center and remove whitespace\n            return {\n                dimensions: newContentDimensions,\n                translations: [\n                    DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim(newContentDimensions[0], state.contentPlacement.translations[0], state.viewportDimensions[0]),\n                    DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim(newContentDimensions[1], state.contentPlacement.translations[1], state.viewportDimensions[1]),\n                ],\n            };\n        };\n    }\n    DragAndZoomPresentationPolicy.getNewContentDimensions = function (currentContentDims, sourceDims, updateEvent) {\n        // If a zoom event is present, apply the zoom factor\n        if (updateEvent && updateEvent.zoom && updateEvent.zoom.relativeFactor) {\n            return currentContentDims.map(function (d) { return d * updateEvent.zoom.relativeFactor; });\n        }\n        if (updateEvent && updateEvent.zoom && updateEvent.zoom.absoluteFactor) {\n            return sourceDims.map(function (d) { return d * updateEvent.zoom.absoluteFactor; });\n        }\n        return currentContentDims;\n    };\n    DragAndZoomPresentationPolicy.centerOrRemoveWhitespaceDim = function (contentDim, translation, viewportDim) {\n        if (contentDim <= viewportDim) {\n            // The content placement's dimension is smaller than the viewport's, center it\n            return viewportDim / 2 - contentDim / 2;\n        }\n        if (translation > 0) {\n            // The content placement has a positive translation, make it flush against that border\n            return 0;\n        }\n        var right = translation + contentDim;\n        if (right < viewportDim) {\n            // The content placement has a positive translation on the other side, make it flush against that border\n            return viewportDim - contentDim;\n        }\n        // The content is zoomed such that there's no whitespace, retain the current translation\n        return translation;\n    };\n    DragAndZoomPresentationPolicy.shouldScaleToFit = function (_a, _b, updateEvent) {\n        var _c = __read(_a, 2), newContentWidth = _c[0], newContentHeight = _c[1];\n        var _d = __read(_b, 2), viewportWidth = _d[0], viewportHeight = _d[1];\n        // Should scale to fit if a reset zoom event occurred or, after applying a zoom event, the content width and height\n        // are smaller than the viewport width and height\n        return ((updateEvent && updateEvent.zoom && updateEvent.zoom.type === PresentationPolicy_1.ZoomType.RESET) ||\n            (newContentWidth <= viewportWidth && newContentHeight <= viewportHeight));\n    };\n    return DragAndZoomPresentationPolicy;\n}());\nexports.default = DragAndZoomPresentationPolicy;\n//# sourceMappingURL=DragAndZoomPresentationPolicy.js.map"]},"metadata":{},"sourceType":"script"}