{"ast":null,"code":"\"use strict\"; // Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\n\nvar DefaultVideoStreamIndex_1 = require(\"./DefaultVideoStreamIndex\");\n\nvar VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[SimulcastTransceiverController]] implements [[VideoStreamIndex]] to facilitate video stream\n * subscription and includes query functions for stream id and attendee id.\n */\n\n\nvar SimulcastVideoStreamIndex =\n/** @class */\nfunction (_super) {\n  __extends(SimulcastVideoStreamIndex, _super);\n\n  function SimulcastVideoStreamIndex(logger) {\n    var _this = _super.call(this, logger) || this;\n\n    _this.streamIdToBitrateKbpsMap = new Map();\n    _this._localStreamInfos = [];\n    _this._lastBitRateMsgTime = Date.now();\n    return _this;\n  }\n\n  SimulcastVideoStreamIndex.prototype.localStreamDescriptions = function () {\n    var clonedDescriptions = [];\n\n    this._localStreamInfos.forEach(function (desc) {\n      clonedDescriptions.push(desc.clone());\n    });\n\n    return clonedDescriptions;\n  };\n\n  SimulcastVideoStreamIndex.prototype.integrateUplinkPolicyDecision = function (encodingParams) {\n    // Reuse local streams (that might already have stream IDs allocated) until\n    // there are no more and then add as many new local streams as needed\n    var hasStreamsToReuse = true;\n    var localStreamIndex = 0;\n\n    for (var i = 0; i < encodingParams.length; i++) {\n      var targetMaxBitrateKbps = encodingParams[i].maxBitrate / 1000;\n      var targetMaxFrameRate = encodingParams[i].maxFramerate;\n\n      if (!hasStreamsToReuse || i === this._localStreamInfos.length) {\n        hasStreamsToReuse = false;\n        var newInfo = new VideoStreamDescription_1.default();\n        newInfo.maxBitrateKbps = targetMaxBitrateKbps;\n        newInfo.maxFrameRate = targetMaxFrameRate;\n        newInfo.disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n\n        if (targetMaxBitrateKbps !== 0) {\n          newInfo.timeEnabled = Date.now();\n        }\n\n        this._localStreamInfos.push(newInfo);\n\n        localStreamIndex++;\n        continue;\n      }\n\n      if (this._localStreamInfos[localStreamIndex].maxBitrateKbps === 0 && targetMaxBitrateKbps > 0) {\n        this._localStreamInfos[localStreamIndex].timeEnabled = Date.now();\n      }\n\n      this._localStreamInfos[localStreamIndex].maxBitrateKbps = targetMaxBitrateKbps;\n      this._localStreamInfos[localStreamIndex].maxFrameRate = targetMaxFrameRate;\n      this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n\n      if (this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy === true) {\n        this._localStreamInfos[localStreamIndex].disabledByWebRTC = false;\n      }\n\n      localStreamIndex++;\n    }\n\n    if (hasStreamsToReuse) {\n      // splice is zero-based, remove stream starting from localStreamIndex\n      this._localStreamInfos.splice(localStreamIndex);\n    }\n  };\n\n  SimulcastVideoStreamIndex.prototype.integrateBitratesFrame = function (bitrateFrame) {\n    var e_1, _a, e_2, _b;\n\n    _super.prototype.integrateBitratesFrame.call(this, bitrateFrame);\n\n    var stillSending = new Set();\n    var existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n\n    try {\n      for (var _c = __values(bitrateFrame.bitrates), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var bitrateMsg = _d.value;\n        stillSending.add(bitrateMsg.sourceStreamId);\n        this.streamIdToBitrateKbpsMap.set(bitrateMsg.sourceStreamId, Math.trunc(bitrateMsg.avgBitrateBps / 1000));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    try {\n      for (var existingSet_1 = __values(existingSet), existingSet_1_1 = existingSet_1.next(); !existingSet_1_1.done; existingSet_1_1 = existingSet_1.next()) {\n        var id = existingSet_1_1.value;\n\n        if (!stillSending.has(id)) {\n          var avgBitrateBps = this.streamIdToBitrateKbpsMap.get(id);\n\n          if (avgBitrateBps === SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE) {\n            this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE);\n          } else {\n            this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE);\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (existingSet_1_1 && !existingSet_1_1.done && (_b = existingSet_1.return)) _b.call(existingSet_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    for (var i = 0; i < this._localStreamInfos.length; i++) {\n      this._localStreamInfos[i].disabledByWebRTC = false;\n      var streamId = this._localStreamInfos[i].streamId;\n\n      if (this._localStreamInfos[i].disabledByUplinkPolicy) {\n        continue;\n      }\n\n      if (this.streamIdToBitrateKbpsMap.has(streamId)) {\n        var avgBitrateKbps = this.streamIdToBitrateKbpsMap.get(streamId);\n\n        if (avgBitrateKbps === SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE && this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled > SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n          this._localStreamInfos[i].disabledByWebRTC = true;\n        }\n      } else {\n        // Do not flag as disabled if it was recently enabled\n        if (this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled > SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n          this._localStreamInfos[i].disabledByWebRTC = true;\n        }\n      }\n    }\n\n    this._lastBitRateMsgTime = Date.now();\n    this.logLocalStreamDescriptions();\n  };\n\n  SimulcastVideoStreamIndex.prototype.logLocalStreamDescriptions = function () {\n    var e_3, _a;\n\n    var msg = '';\n\n    try {\n      for (var _b = __values(this._localStreamInfos), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var desc = _c.value;\n        msg += \"streamId=\" + desc.streamId + \" maxBitrate=\" + desc.maxBitrateKbps + \" disabledByWebRTC=\" + desc.disabledByWebRTC + \" disabledByUplink=\" + desc.disabledByUplinkPolicy + \"\\n\";\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    this.logger.debug(function () {\n      return msg;\n    });\n  };\n\n  SimulcastVideoStreamIndex.prototype.integrateIndexFrame = function (indexFrame) {\n    var e_4, _a, e_5, _b;\n\n    _super.prototype.integrateIndexFrame.call(this, indexFrame);\n\n    var newIndexStreamIdSet = new Set();\n    var existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n\n    try {\n      for (var _c = __values(this.currentIndex.sources), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var stream = _d.value;\n\n        if (stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n          continue;\n        }\n\n        newIndexStreamIdSet.add(stream.streamId);\n\n        if (!this.streamIdToBitrateKbpsMap.has(stream.streamId)) {\n          this.streamIdToBitrateKbpsMap.set(stream.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    try {\n      for (var existingSet_2 = __values(existingSet), existingSet_2_1 = existingSet_2.next(); !existingSet_2_1.done; existingSet_2_1 = existingSet_2.next()) {\n        var id = existingSet_2_1.value;\n\n        if (!newIndexStreamIdSet.has(id)) {\n          this.streamIdToBitrateKbpsMap.delete(id);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (existingSet_2_1 && !existingSet_2_1.done && (_b = existingSet_2.return)) _b.call(existingSet_2);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n  };\n\n  SimulcastVideoStreamIndex.prototype.integrateSubscribeAckFrame = function (subscribeAck) {\n    var e_6, _a;\n\n    _super.prototype.integrateSubscribeAckFrame.call(this, subscribeAck);\n\n    if (!subscribeAck.allocations || subscribeAck.allocations === undefined) {\n      return;\n    }\n\n    var localStreamStartIndex = 0;\n\n    try {\n      for (var _b = __values(subscribeAck.allocations), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var allocation = _c.value; // track label is what we offered to the server\n\n        if (this._localStreamInfos.length < localStreamStartIndex + 1) {\n          this.logger.info('simulcast: allocation has more than number of local streams');\n          break;\n        }\n\n        this._localStreamInfos[localStreamStartIndex].groupId = allocation.groupId;\n        this._localStreamInfos[localStreamStartIndex].streamId = allocation.streamId;\n\n        if (!this.streamIdToBitrateKbpsMap.has(allocation.streamId)) {\n          this.streamIdToBitrateKbpsMap.set(allocation.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n        }\n\n        localStreamStartIndex++;\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  }; // First time when the bitrate of a stream id is missing from bitrate message, mark it as UNSEEN\n\n\n  SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE = -2; // Second time when the bitrate is missing, mark it as recently inactive\n\n  SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE = -1; // Third time when bitrate is missing, mark it as not sending\n\n  SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE = 0;\n  SimulcastVideoStreamIndex.BitratesMsgFrequencyMs = 4000;\n  return SimulcastVideoStreamIndex;\n}(DefaultVideoStreamIndex_1.default);\n\nexports.default = SimulcastVideoStreamIndex;","map":{"version":3,"sources":["../../src/videostreamindex/SimulcastVideoStreamIndex.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,IAAA,sBAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AAMA,IAAA,yBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,IAAA,wBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;AAEA;;;AAGG;;;AACH,IAAA,yBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAuD,EAAA,SAAA,CAAA,yBAAA,EAAA,MAAA,CAAA;;AAgBrD,WAAA,yBAAA,CAAY,MAAZ,EAA0B;AAA1B,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAN,KAAa,IADf;;AAfQ,IAAA,KAAA,CAAA,wBAAA,GAAgD,IAAI,GAAJ,EAAhD;AAWA,IAAA,KAAA,CAAA,iBAAA,GAA8C,EAA9C;AAMN,IAAA,KAAI,CAAC,mBAAL,GAA2B,IAAI,CAAC,GAAL,EAA3B;;AACD;;AAED,EAAA,yBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,YAAA;AACE,QAAM,kBAAkB,GAA6B,EAArD;;AACA,SAAK,iBAAL,CAAuB,OAAvB,CAA+B,UAAA,IAAA,EAAI;AACjC,MAAA,kBAAkB,CAAC,IAAnB,CAAwB,IAAI,CAAC,KAAL,EAAxB;AACD,KAFD;;AAGA,WAAO,kBAAP;AACD,GAND;;AAQA,EAAA,yBAAA,CAAA,SAAA,CAAA,6BAAA,GAAA,UAA8B,cAA9B,EAAwE;AACtE;AACA;AACA,QAAI,iBAAiB,GAAG,IAAxB;AACA,QAAI,gBAAgB,GAAG,CAAvB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,cAAc,CAAC,MAAnC,EAA2C,CAAC,EAA5C,EAAgD;AAC9C,UAAM,oBAAoB,GAAG,cAAc,CAAC,CAAD,CAAd,CAAkB,UAAlB,GAA+B,IAA5D;AACA,UAAM,kBAAkB,GAAG,cAAc,CAAC,CAAD,CAAd,CAAkB,YAA7C;;AACA,UAAI,CAAC,iBAAD,IAAsB,CAAC,KAAK,KAAK,iBAAL,CAAuB,MAAvD,EAA+D;AAC7D,QAAA,iBAAiB,GAAG,KAApB;AACA,YAAM,OAAO,GAAG,IAAI,wBAAA,CAAA,OAAJ,EAAhB;AACA,QAAA,OAAO,CAAC,cAAR,GAAyB,oBAAzB;AACA,QAAA,OAAO,CAAC,YAAR,GAAuB,kBAAvB;AACA,QAAA,OAAO,CAAC,sBAAR,GAAiC,oBAAoB,KAAK,CAAzB,GAA6B,IAA7B,GAAoC,KAArE;;AACA,YAAI,oBAAoB,KAAK,CAA7B,EAAgC;AAC9B,UAAA,OAAO,CAAC,WAAR,GAAsB,IAAI,CAAC,GAAL,EAAtB;AACD;;AACD,aAAK,iBAAL,CAAuB,IAAvB,CAA4B,OAA5B;;AACA,QAAA,gBAAgB;AAChB;AACD;;AAED,UACE,KAAK,iBAAL,CAAuB,gBAAvB,EAAyC,cAAzC,KAA4D,CAA5D,IACA,oBAAoB,GAAG,CAFzB,EAGE;AACA,aAAK,iBAAL,CAAuB,gBAAvB,EAAyC,WAAzC,GAAuD,IAAI,CAAC,GAAL,EAAvD;AACD;;AACD,WAAK,iBAAL,CAAuB,gBAAvB,EAAyC,cAAzC,GAA0D,oBAA1D;AACA,WAAK,iBAAL,CAAuB,gBAAvB,EAAyC,YAAzC,GAAwD,kBAAxD;AACA,WAAK,iBAAL,CAAuB,gBAAvB,EAAyC,sBAAzC,GACE,oBAAoB,KAAK,CAAzB,GAA6B,IAA7B,GAAoC,KADtC;;AAEA,UAAI,KAAK,iBAAL,CAAuB,gBAAvB,EAAyC,sBAAzC,KAAoE,IAAxE,EAA8E;AAC5E,aAAK,iBAAL,CAAuB,gBAAvB,EAAyC,gBAAzC,GAA4D,KAA5D;AACD;;AACD,MAAA,gBAAgB;AACjB;;AAED,QAAI,iBAAJ,EAAuB;AACrB;AACA,WAAK,iBAAL,CAAuB,MAAvB,CAA8B,gBAA9B;AACD;AACF,GA1CD;;AA4CA,EAAA,yBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,YAAvB,EAAoD;;;AAClD,IAAA,MAAA,CAAA,SAAA,CAAM,sBAAN,CAA4B,IAA5B,CAA4B,IAA5B,EAA6B,YAA7B;;AAEA,QAAM,YAAY,GAAG,IAAI,GAAJ,EAArB;AACA,QAAM,WAAW,GAAG,IAAI,GAAJ,CAAgB,KAAK,wBAAL,CAA8B,IAA9B,EAAhB,CAApB;;;AACA,WAAyB,IAAA,EAAA,GAAA,QAAA,CAAA,YAAY,CAAC,QAAb,CAAA,EAAqB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA9C,EAA8C,CAAA,EAAA,CAAA,IAA9C,EAA8C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA9C,EAAgD;AAA3C,YAAM,UAAU,GAAA,EAAA,CAAA,KAAhB;AACH,QAAA,YAAY,CAAC,GAAb,CAAiB,UAAU,CAAC,cAA5B;AACA,aAAK,wBAAL,CAA8B,GAA9B,CACE,UAAU,CAAC,cADb,EAEE,IAAI,CAAC,KAAL,CAAW,UAAU,CAAC,aAAX,GAA2B,IAAtC,CAFF;AAID;;;;;;;;;;;;;;AAED,WAAiB,IAAA,aAAA,GAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,eAAA,CAAA,IAA5B,EAA4B,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,EAAE,GAAA,eAAA,CAAA,KAAR;;AACH,YAAI,CAAC,YAAY,CAAC,GAAb,CAAiB,EAAjB,CAAL,EAA2B;AACzB,cAAM,aAAa,GAAG,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,EAAlC,CAAtB;;AACA,cAAI,aAAa,KAAK,yBAAyB,CAAC,qBAAhD,EAAuE;AACrE,iBAAK,wBAAL,CAA8B,GAA9B,CACE,EADF,EAEE,yBAAyB,CAAC,gCAF5B;AAID,WALD,MAKO;AACL,iBAAK,wBAAL,CAA8B,GAA9B,CACE,EADF,EAEE,yBAAyB,CAAC,0BAF5B;AAID;AACF;AACF;;;;;;;;;;;;;AAED,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,iBAAL,CAAuB,MAA3C,EAAmD,CAAC,EAApD,EAAwD;AACtD,WAAK,iBAAL,CAAuB,CAAvB,EAA0B,gBAA1B,GAA6C,KAA7C;AACA,UAAM,QAAQ,GAAG,KAAK,iBAAL,CAAuB,CAAvB,EAA0B,QAA3C;;AACA,UAAI,KAAK,iBAAL,CAAuB,CAAvB,EAA0B,sBAA9B,EAAsD;AACpD;AACD;;AACD,UAAI,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,QAAlC,CAAJ,EAAiD;AAC/C,YAAM,cAAc,GAAG,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,QAAlC,CAAvB;;AACA,YACE,cAAc,KAAK,yBAAyB,CAAC,0BAA7C,IACA,KAAK,mBAAL,GAA2B,KAAK,iBAAL,CAAuB,CAAvB,EAA0B,WAArD,GACE,yBAAyB,CAAC,sBAH9B,EAIE;AACA,eAAK,iBAAL,CAAuB,CAAvB,EAA0B,gBAA1B,GAA6C,IAA7C;AACD;AACF,OATD,MASO;AACL;AACA,YACE,KAAK,mBAAL,GAA2B,KAAK,iBAAL,CAAuB,CAAvB,EAA0B,WAArD,GACA,yBAAyB,CAAC,sBAF5B,EAGE;AACA,eAAK,iBAAL,CAAuB,CAAvB,EAA0B,gBAA1B,GAA6C,IAA7C;AACD;AACF;AACF;;AACD,SAAK,mBAAL,GAA2B,IAAI,CAAC,GAAL,EAA3B;AACA,SAAK,0BAAL;AACD,GAzDD;;AA2DQ,EAAA,yBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,YAAA;;;AACE,QAAI,GAAG,GAAG,EAAV;;;AACA,WAAmB,IAAA,EAAA,GAAA,QAAA,CAAA,KAAK,iBAAL,CAAA,EAAsB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAAyC,CAAA,EAAA,CAAA,IAAzC,EAAyC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAA2C;AAAtC,YAAM,IAAI,GAAA,EAAA,CAAA,KAAV;AACH,QAAA,GAAG,IAAI,cAAY,IAAI,CAAC,QAAjB,GAAyB,cAAzB,GAAwC,IAAI,CAAC,cAA7C,GAA2D,oBAA3D,GAAgF,IAAI,CAAC,gBAArF,GAAqG,oBAArG,GAA0H,IAAI,CAAC,sBAA/H,GAAqJ,IAA5J;AACD;;;;;;;;;;;;;AACD,SAAK,MAAL,CAAY,KAAZ,CAAkB,YAAA;AAChB,aAAO,GAAP;AACD,KAFD;AAGD,GARO;;AAUR,EAAA,yBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,UAApB,EAA6C;;;AAC3C,IAAA,MAAA,CAAA,SAAA,CAAM,mBAAN,CAAyB,IAAzB,CAAyB,IAAzB,EAA0B,UAA1B;;AAEA,QAAM,mBAAmB,GAAG,IAAI,GAAJ,EAA5B;AACA,QAAM,WAAW,GAAG,IAAI,GAAJ,CAAgB,KAAK,wBAAL,CAA8B,IAA9B,EAAhB,CAApB;;;AACA,WAAqB,IAAA,EAAA,GAAA,QAAA,CAAA,KAAK,YAAL,CAAkB,OAAlB,CAAA,EAAyB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA9C,EAA8C,CAAA,EAAA,CAAA,IAA9C,EAA8C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA9C,EAAgD;AAA3C,YAAM,MAAM,GAAA,EAAA,CAAA,KAAZ;;AACH,YAAI,MAAM,CAAC,SAAP,KAAqB,sBAAA,CAAA,kBAAA,CAAmB,KAA5C,EAAmD;AACjD;AACD;;AACD,QAAA,mBAAmB,CAAC,GAApB,CAAwB,MAAM,CAAC,QAA/B;;AACA,YAAI,CAAC,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,MAAM,CAAC,QAAzC,CAAL,EAAyD;AACvD,eAAK,wBAAL,CAA8B,GAA9B,CACE,MAAM,CAAC,QADT,EAEE,yBAAyB,CAAC,qBAF5B;AAID;AACF;;;;;;;;;;;;;;AAED,WAAiB,IAAA,aAAA,GAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,eAAA,CAAA,IAA5B,EAA4B,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,EAAE,GAAA,eAAA,CAAA,KAAR;;AACH,YAAI,CAAC,mBAAmB,CAAC,GAApB,CAAwB,EAAxB,CAAL,EAAkC;AAChC,eAAK,wBAAL,CAA8B,MAA9B,CAAqC,EAArC;AACD;AACF;;;;;;;;;;;;AACF,GAvBD;;AAyBA,EAAA,yBAAA,CAAA,SAAA,CAAA,0BAAA,GAAA,UAA2B,YAA3B,EAA6D;;;AAC3D,IAAA,MAAA,CAAA,SAAA,CAAM,0BAAN,CAAgC,IAAhC,CAAgC,IAAhC,EAAiC,YAAjC;;AACA,QAAI,CAAC,YAAY,CAAC,WAAd,IAA6B,YAAY,CAAC,WAAb,KAA6B,SAA9D,EAAyE;AACvE;AACD;;AAED,QAAI,qBAAqB,GAAG,CAA5B;;;AACA,WAAyB,IAAA,EAAA,GAAA,QAAA,CAAA,YAAY,CAAC,WAAb,CAAA,EAAwB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAiD,CAAA,EAAA,CAAA,IAAjD,EAAiD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAmD;AAA9C,YAAM,UAAU,GAAA,EAAA,CAAA,KAAhB,CAA8C,CACjD;;AACA,YAAI,KAAK,iBAAL,CAAuB,MAAvB,GAAgC,qBAAqB,GAAG,CAA5D,EAA+D;AAC7D,eAAK,MAAL,CAAY,IAAZ,CAAiB,6DAAjB;AACA;AACD;;AACD,aAAK,iBAAL,CAAuB,qBAAvB,EAA8C,OAA9C,GAAwD,UAAU,CAAC,OAAnE;AACA,aAAK,iBAAL,CAAuB,qBAAvB,EAA8C,QAA9C,GAAyD,UAAU,CAAC,QAApE;;AACA,YAAI,CAAC,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,UAAU,CAAC,QAA7C,CAAL,EAA6D;AAC3D,eAAK,wBAAL,CAA8B,GAA9B,CACE,UAAU,CAAC,QADb,EAEE,yBAAyB,CAAC,qBAF5B;AAID;;AACD,QAAA,qBAAqB;AACtB;;;;;;;;;;;;AACF,GAvBD,CAvKF,CAGE;;;AACgB,EAAA,yBAAA,CAAA,qBAAA,GAAwB,CAAC,CAAzB,CAJlB,CAKE;;AACgB,EAAA,yBAAA,CAAA,gCAAA,GAAmC,CAAC,CAApC,CANlB,CAOE;;AACgB,EAAA,yBAAA,CAAA,0BAAA,GAA6B,CAA7B;AAEA,EAAA,yBAAA,CAAA,sBAAA,GAAiC,IAAjC;AAqLlB,SAAA,yBAAA;AAAC,CA/LD,CAAuD,yBAAA,CAAA,OAAvD,CAAA;;kBAAqB,yB","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SignalingProtocol_js_1 = require(\"../signalingprotocol/SignalingProtocol.js\");\nvar DefaultVideoStreamIndex_1 = require(\"./DefaultVideoStreamIndex\");\nvar VideoStreamDescription_1 = require(\"./VideoStreamDescription\");\n/**\n * [[SimulcastTransceiverController]] implements [[VideoStreamIndex]] to facilitate video stream\n * subscription and includes query functions for stream id and attendee id.\n */\nvar SimulcastVideoStreamIndex = /** @class */ (function (_super) {\n    __extends(SimulcastVideoStreamIndex, _super);\n    function SimulcastVideoStreamIndex(logger) {\n        var _this = _super.call(this, logger) || this;\n        _this.streamIdToBitrateKbpsMap = new Map();\n        _this._localStreamInfos = [];\n        _this._lastBitRateMsgTime = Date.now();\n        return _this;\n    }\n    SimulcastVideoStreamIndex.prototype.localStreamDescriptions = function () {\n        var clonedDescriptions = [];\n        this._localStreamInfos.forEach(function (desc) {\n            clonedDescriptions.push(desc.clone());\n        });\n        return clonedDescriptions;\n    };\n    SimulcastVideoStreamIndex.prototype.integrateUplinkPolicyDecision = function (encodingParams) {\n        // Reuse local streams (that might already have stream IDs allocated) until\n        // there are no more and then add as many new local streams as needed\n        var hasStreamsToReuse = true;\n        var localStreamIndex = 0;\n        for (var i = 0; i < encodingParams.length; i++) {\n            var targetMaxBitrateKbps = encodingParams[i].maxBitrate / 1000;\n            var targetMaxFrameRate = encodingParams[i].maxFramerate;\n            if (!hasStreamsToReuse || i === this._localStreamInfos.length) {\n                hasStreamsToReuse = false;\n                var newInfo = new VideoStreamDescription_1.default();\n                newInfo.maxBitrateKbps = targetMaxBitrateKbps;\n                newInfo.maxFrameRate = targetMaxFrameRate;\n                newInfo.disabledByUplinkPolicy = targetMaxBitrateKbps === 0 ? true : false;\n                if (targetMaxBitrateKbps !== 0) {\n                    newInfo.timeEnabled = Date.now();\n                }\n                this._localStreamInfos.push(newInfo);\n                localStreamIndex++;\n                continue;\n            }\n            if (this._localStreamInfos[localStreamIndex].maxBitrateKbps === 0 &&\n                targetMaxBitrateKbps > 0) {\n                this._localStreamInfos[localStreamIndex].timeEnabled = Date.now();\n            }\n            this._localStreamInfos[localStreamIndex].maxBitrateKbps = targetMaxBitrateKbps;\n            this._localStreamInfos[localStreamIndex].maxFrameRate = targetMaxFrameRate;\n            this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy =\n                targetMaxBitrateKbps === 0 ? true : false;\n            if (this._localStreamInfos[localStreamIndex].disabledByUplinkPolicy === true) {\n                this._localStreamInfos[localStreamIndex].disabledByWebRTC = false;\n            }\n            localStreamIndex++;\n        }\n        if (hasStreamsToReuse) {\n            // splice is zero-based, remove stream starting from localStreamIndex\n            this._localStreamInfos.splice(localStreamIndex);\n        }\n    };\n    SimulcastVideoStreamIndex.prototype.integrateBitratesFrame = function (bitrateFrame) {\n        var e_1, _a, e_2, _b;\n        _super.prototype.integrateBitratesFrame.call(this, bitrateFrame);\n        var stillSending = new Set();\n        var existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n        try {\n            for (var _c = __values(bitrateFrame.bitrates), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var bitrateMsg = _d.value;\n                stillSending.add(bitrateMsg.sourceStreamId);\n                this.streamIdToBitrateKbpsMap.set(bitrateMsg.sourceStreamId, Math.trunc(bitrateMsg.avgBitrateBps / 1000));\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        try {\n            for (var existingSet_1 = __values(existingSet), existingSet_1_1 = existingSet_1.next(); !existingSet_1_1.done; existingSet_1_1 = existingSet_1.next()) {\n                var id = existingSet_1_1.value;\n                if (!stillSending.has(id)) {\n                    var avgBitrateBps = this.streamIdToBitrateKbpsMap.get(id);\n                    if (avgBitrateBps === SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE) {\n                        this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE);\n                    }\n                    else {\n                        this.streamIdToBitrateKbpsMap.set(id, SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE);\n                    }\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (existingSet_1_1 && !existingSet_1_1.done && (_b = existingSet_1.return)) _b.call(existingSet_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        for (var i = 0; i < this._localStreamInfos.length; i++) {\n            this._localStreamInfos[i].disabledByWebRTC = false;\n            var streamId = this._localStreamInfos[i].streamId;\n            if (this._localStreamInfos[i].disabledByUplinkPolicy) {\n                continue;\n            }\n            if (this.streamIdToBitrateKbpsMap.has(streamId)) {\n                var avgBitrateKbps = this.streamIdToBitrateKbpsMap.get(streamId);\n                if (avgBitrateKbps === SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE &&\n                    this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled >\n                        SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n                    this._localStreamInfos[i].disabledByWebRTC = true;\n                }\n            }\n            else {\n                // Do not flag as disabled if it was recently enabled\n                if (this._lastBitRateMsgTime - this._localStreamInfos[i].timeEnabled >\n                    SimulcastVideoStreamIndex.BitratesMsgFrequencyMs) {\n                    this._localStreamInfos[i].disabledByWebRTC = true;\n                }\n            }\n        }\n        this._lastBitRateMsgTime = Date.now();\n        this.logLocalStreamDescriptions();\n    };\n    SimulcastVideoStreamIndex.prototype.logLocalStreamDescriptions = function () {\n        var e_3, _a;\n        var msg = '';\n        try {\n            for (var _b = __values(this._localStreamInfos), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var desc = _c.value;\n                msg += \"streamId=\" + desc.streamId + \" maxBitrate=\" + desc.maxBitrateKbps + \" disabledByWebRTC=\" + desc.disabledByWebRTC + \" disabledByUplink=\" + desc.disabledByUplinkPolicy + \"\\n\";\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        this.logger.debug(function () {\n            return msg;\n        });\n    };\n    SimulcastVideoStreamIndex.prototype.integrateIndexFrame = function (indexFrame) {\n        var e_4, _a, e_5, _b;\n        _super.prototype.integrateIndexFrame.call(this, indexFrame);\n        var newIndexStreamIdSet = new Set();\n        var existingSet = new Set(this.streamIdToBitrateKbpsMap.keys());\n        try {\n            for (var _c = __values(this.currentIndex.sources), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var stream = _d.value;\n                if (stream.mediaType !== SignalingProtocol_js_1.SdkStreamMediaType.VIDEO) {\n                    continue;\n                }\n                newIndexStreamIdSet.add(stream.streamId);\n                if (!this.streamIdToBitrateKbpsMap.has(stream.streamId)) {\n                    this.streamIdToBitrateKbpsMap.set(stream.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        try {\n            for (var existingSet_2 = __values(existingSet), existingSet_2_1 = existingSet_2.next(); !existingSet_2_1.done; existingSet_2_1 = existingSet_2.next()) {\n                var id = existingSet_2_1.value;\n                if (!newIndexStreamIdSet.has(id)) {\n                    this.streamIdToBitrateKbpsMap.delete(id);\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (existingSet_2_1 && !existingSet_2_1.done && (_b = existingSet_2.return)) _b.call(existingSet_2);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n    };\n    SimulcastVideoStreamIndex.prototype.integrateSubscribeAckFrame = function (subscribeAck) {\n        var e_6, _a;\n        _super.prototype.integrateSubscribeAckFrame.call(this, subscribeAck);\n        if (!subscribeAck.allocations || subscribeAck.allocations === undefined) {\n            return;\n        }\n        var localStreamStartIndex = 0;\n        try {\n            for (var _b = __values(subscribeAck.allocations), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var allocation = _c.value;\n                // track label is what we offered to the server\n                if (this._localStreamInfos.length < localStreamStartIndex + 1) {\n                    this.logger.info('simulcast: allocation has more than number of local streams');\n                    break;\n                }\n                this._localStreamInfos[localStreamStartIndex].groupId = allocation.groupId;\n                this._localStreamInfos[localStreamStartIndex].streamId = allocation.streamId;\n                if (!this.streamIdToBitrateKbpsMap.has(allocation.streamId)) {\n                    this.streamIdToBitrateKbpsMap.set(allocation.streamId, SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE);\n                }\n                localStreamStartIndex++;\n            }\n        }\n        catch (e_6_1) { e_6 = { error: e_6_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_6) throw e_6.error; }\n        }\n    };\n    // First time when the bitrate of a stream id is missing from bitrate message, mark it as UNSEEN\n    SimulcastVideoStreamIndex.UNSEEN_STREAM_BITRATE = -2;\n    // Second time when the bitrate is missing, mark it as recently inactive\n    SimulcastVideoStreamIndex.RECENTLY_INACTIVE_STREAM_BITRATE = -1;\n    // Third time when bitrate is missing, mark it as not sending\n    SimulcastVideoStreamIndex.NOT_SENDING_STREAM_BITRATE = 0;\n    SimulcastVideoStreamIndex.BitratesMsgFrequencyMs = 4000;\n    return SimulcastVideoStreamIndex;\n}(DefaultVideoStreamIndex_1.default));\nexports.default = SimulcastVideoStreamIndex;\n//# sourceMappingURL=SimulcastVideoStreamIndex.js.map"]},"metadata":{},"sourceType":"script"}