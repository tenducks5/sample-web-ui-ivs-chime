{"ast":null,"code":"\"use strict\"; // Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ClientMetricReportDirection_1 = require(\"../clientmetricreport/ClientMetricReportDirection\");\n\nvar ContentShareConstants_1 = require(\"../contentsharecontroller/ContentShareConstants\");\n\nvar DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\n\nvar LinkMediaStats =\n/** @class */\nfunction () {\n  function LinkMediaStats() {\n    this.bandwidthEstimateKbps = 0;\n    this.usedBandwidthKbps = 0;\n    this.packetsLost = 0;\n    this.nackCount = 0;\n    this.rttMs = 0;\n  }\n\n  return LinkMediaStats;\n}();\n\nvar VideoAdaptiveProbePolicy =\n/** @class */\nfunction () {\n  function VideoAdaptiveProbePolicy(logger, tileController) {\n    this.logger = logger;\n    this.tileController = tileController;\n    this.reset();\n  }\n\n  VideoAdaptiveProbePolicy.prototype.reset = function () {\n    this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();\n    this.logCount = 0;\n    this.startupPeriod = true;\n    this.usingPrevTargetRate = false;\n    this.rateProbeState = \"Not Probing\"\n    /* kNotProbing */\n    ;\n    this.timeFirstEstimate = 0;\n    this.lastUpgradeRateKbps = 0;\n    this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n    this.timeLastProbe = Date.now();\n    this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n    this.downlinkStats = new LinkMediaStats();\n    this.prevDownlinkStats = new LinkMediaStats();\n  };\n\n  VideoAdaptiveProbePolicy.prototype.updateIndex = function (videoIndex) {\n    this.videoIndex = videoIndex;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.updateMetrics = function (clientMetricReport) {\n    if (this.videoIndex.allStreams().empty()) {\n      return;\n    }\n\n    this.prevDownlinkStats = this.downlinkStats;\n    this.downlinkStats = new LinkMediaStats();\n    var metricReport = clientMetricReport.getObservableMetrics();\n    this.downlinkStats.bandwidthEstimateKbps = metricReport.availableReceiveBandwidth / 1000;\n\n    for (var ssrcStr in clientMetricReport.streamMetricReports) {\n      var ssrc = Number(ssrcStr);\n\n      if (clientMetricReport.streamMetricReports[ssrc].direction === ClientMetricReportDirection_1.default.DOWNSTREAM) {\n        // Only use video stream metrics\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googNacksSent') && clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n          this.downlinkStats.nackCount += clientMetricReport.countPerSecond('googNacksSent', ssrc);\n        }\n\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('packetsLost') && clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n          this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n        }\n\n        if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('bytesReceived')) {\n          this.downlinkStats.usedBandwidthKbps += clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n        }\n      }\n    }\n  };\n\n  VideoAdaptiveProbePolicy.prototype.wantsResubscribe = function () {\n    this.optimalReceiveSet = this.calculateOptimalReceiveSet();\n    return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n  };\n\n  VideoAdaptiveProbePolicy.prototype.chooseSubscriptions = function () {\n    if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n      this.timeLastSubscribe = Date.now();\n    }\n\n    this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n    this.logger.info('bwe: chooseSubscriptions ' + JSON.stringify(this.subscribedReceiveSet));\n    return this.subscribedReceiveSet.clone();\n  };\n\n  VideoAdaptiveProbePolicy.prototype.calculateOptimalReceiveSet = function () {\n    var e_1, _a, e_2, _b, e_3, _c;\n\n    var streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n    var lastProbeState = this.rateProbeState;\n    var remoteInfos = this.videoIndex.remoteStreamDescriptions();\n\n    if (remoteInfos.length === 0) {\n      return streamSelectionSet;\n    }\n\n    var pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n    this.handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos);\n    var sameStreamChoices = this.availStreamsSameAsLast(remoteInfos); // If no major changes then don't allow subscribes for the allowed amount of time\n\n    if (!this.startupPeriod && sameStreamChoices && Date.now() - this.timeLastSubscribe < this.timeBeforeAllowSubscribeMs) {\n      return this.optimalReceiveSet;\n    } // reset time before allow subscribe to default\n\n\n    this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n    var chosenStreams = []; // Sort streams by bitrate asceending.\n\n    remoteInfos.sort(function (a, b) {\n      if (a.maxBitrateKbps === b.maxBitrateKbps) {\n        return a.streamId - b.streamId;\n      }\n\n      return a.maxBitrateKbps - b.maxBitrateKbps;\n    });\n\n    try {\n      // Convert 0 avg bitrates to max and handle special cases\n      for (var remoteInfos_1 = __values(remoteInfos), remoteInfos_1_1 = remoteInfos_1.next(); !remoteInfos_1_1.done; remoteInfos_1_1 = remoteInfos_1.next()) {\n        var info = remoteInfos_1_1.value;\n\n        if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n          // Content can be a special case\n          if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality) && info.maxBitrateKbps < 100) {\n            info.maxBitrateKbps = info.avgBitrateKbps;\n          } else {\n            info.avgBitrateKbps = info.maxBitrateKbps;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_1_1 && !remoteInfos_1_1.done && (_a = remoteInfos_1.return)) _a.call(remoteInfos_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var targetDownlinkBitrate = this.determineTargetRate(remoteInfos);\n    var deltaToNextUpgrade = 0;\n    var chosenTotalBitrate = 0;\n    var upgradeStream; // If screen share is available, then subscribe to that first before anything else\n\n    chosenTotalBitrate += this.chooseContent(chosenStreams, remoteInfos);\n\n    var _loop_1 = function (info) {\n      if (info.avgBitrateKbps === 0) {\n        return \"continue\";\n      }\n\n      if (chosenStreams.findIndex(function (stream) {\n        return stream.groupId === info.groupId;\n      }) === -1) {\n        if (chosenTotalBitrate + info.avgBitrateKbps <= targetDownlinkBitrate) {\n          chosenStreams.push(info);\n          chosenTotalBitrate += info.avgBitrateKbps;\n        } else if (deltaToNextUpgrade === 0) {\n          // Keep track of step to next upgrade\n          deltaToNextUpgrade = info.avgBitrateKbps;\n          upgradeStream = info;\n        }\n      }\n    };\n\n    try {\n      // Try to have at least one stream from every group first\n      // Since the streams are sorted this will pick the lowest bitrates first\n      for (var remoteInfos_2 = __values(remoteInfos), remoteInfos_2_1 = remoteInfos_2.next(); !remoteInfos_2_1.done; remoteInfos_2_1 = remoteInfos_2.next()) {\n        var info = remoteInfos_2_1.value;\n\n        _loop_1(info);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_2_1 && !remoteInfos_2_1.done && (_b = remoteInfos_2.return)) _b.call(remoteInfos_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Look for upgrades until we run out of bandwidth\n\n\n    var lookForUpgrades = true;\n\n    while (lookForUpgrades) {\n      // We will set this to true if we find any new upgrades during the loop over the\n      // chosen streams (i.e. when we do a full loop without an upgrade we will give up)\n      lookForUpgrades = false;\n      chosenStreams.forEach(function (chosenStream, index) {\n        var e_4, _a;\n\n        try {\n          for (var remoteInfos_3 = (e_4 = void 0, __values(remoteInfos)), remoteInfos_3_1 = remoteInfos_3.next(); !remoteInfos_3_1.done; remoteInfos_3_1 = remoteInfos_3.next()) {\n            var info = remoteInfos_3_1.value;\n\n            if (info.groupId === chosenStream.groupId && info.streamId !== chosenStream.streamId && info.avgBitrateKbps > chosenStream.avgBitrateKbps) {\n              var increaseKbps = info.avgBitrateKbps - chosenStream.avgBitrateKbps;\n\n              if (chosenTotalBitrate + increaseKbps <= targetDownlinkBitrate) {\n                chosenTotalBitrate += increaseKbps;\n                chosenStreams[index] = info;\n                lookForUpgrades = true;\n              } else if (deltaToNextUpgrade === 0) {\n                // Keep track of step to next upgrade\n                deltaToNextUpgrade = increaseKbps;\n                upgradeStream = info;\n              }\n            }\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (remoteInfos_3_1 && !remoteInfos_3_1.done && (_a = remoteInfos_3.return)) _a.call(remoteInfos_3);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n      });\n    }\n\n    var subscriptionChoice = 0\n    /* kNewOptimal */\n    ; // Look for probing or override opportunities\n\n    if (!this.startupPeriod && sameStreamChoices && deltaToNextUpgrade !== 0) {\n      if (this.rateProbeState === \"Probing\"\n      /* kProbing */\n      ) {\n          subscriptionChoice = this.handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos);\n        } else {\n        subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, chosenTotalBitrate, deltaToNextUpgrade, upgradeStream);\n      }\n    } else {\n      // If there was a change in streams to choose from, then cancel any probing or upgrades\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n    }\n\n    var decisionLogStr = this.policyStateLogStr(remoteInfos, targetDownlinkBitrate);\n\n    if (this.logCount % 15 === 0 || this.rateProbeState !== lastProbeState) {\n      this.logger.info(decisionLogStr);\n      this.logCount = 0;\n      decisionLogStr = '';\n    }\n\n    this.logCount++;\n    this.prevTargetRateKbps = targetDownlinkBitrate;\n    this.prevRemoteInfos = remoteInfos;\n\n    if (subscriptionChoice === 1\n    /* kPreviousOptimal */\n    ) {\n        this.logger.info('bwe: keepSameSubscriptions');\n\n        if (decisionLogStr.length > 0) {\n          this.logger.info(decisionLogStr);\n        }\n\n        return this.optimalReceiveSet;\n      } else if (subscriptionChoice === 2\n    /* kPreProbe */\n    ) {\n        var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.preProbeReceiveSet);\n        this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n        return this.preProbeReceiveSet;\n      }\n\n    try {\n      for (var chosenStreams_1 = __values(chosenStreams), chosenStreams_1_1 = chosenStreams_1.next(); !chosenStreams_1_1.done; chosenStreams_1_1 = chosenStreams_1.next()) {\n        var chosenStream = chosenStreams_1_1.value;\n        streamSelectionSet.add(chosenStream.streamId);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (chosenStreams_1_1 && !chosenStreams_1_1.done && (_c = chosenStreams_1.return)) _c.call(chosenStreams_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n      if (decisionLogStr.length > 0) {\n        this.logger.info(decisionLogStr);\n      }\n\n      var subscribedRate = this.calculateSubscribeRate(remoteInfos, streamSelectionSet);\n      this.logger.info(\"bwe: new streamSelection: \" + JSON.stringify(streamSelectionSet) + \" subscribedRate:\" + subscribedRate);\n    }\n\n    return streamSelectionSet;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.determineTargetRate = function (remoteInfos) {\n    var e_5, _a;\n\n    var _this = this;\n\n    var targetBitrate = 0; // Estimated downlink bandwidth from WebRTC is dependent on actually receiving data, so if it ever got driven below the bitrate of the lowest\n    // stream (a simulcast stream), and it stops receiving, it will get stuck never being able to resubscribe (as is implemented).\n\n    var minTargetDownlinkBitrate = Number.MAX_VALUE;\n\n    try {\n      for (var remoteInfos_4 = __values(remoteInfos), remoteInfos_4_1 = remoteInfos_4.next(); !remoteInfos_4_1.done; remoteInfos_4_1 = remoteInfos_4.next()) {\n        var info = remoteInfos_4_1.value;\n\n        if (info.avgBitrateKbps !== 0 && info.avgBitrateKbps < minTargetDownlinkBitrate) {\n          minTargetDownlinkBitrate = info.avgBitrateKbps;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_4_1 && !remoteInfos_4_1.done && (_a = remoteInfos_4.return)) _a.call(remoteInfos_4);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    var now = Date.now(); // Startup phase handling.  During this period the estimate can be 0 or\n    // could still be slowly hunting for a steady state.  This startup ramp up\n    // can cause a series of subscribes which can be distracting. During this\n    // time just use our configured default value\n\n    if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n      if (this.timeFirstEstimate === 0) {\n        this.timeFirstEstimate = now;\n      } // handle startup state where estimator is still converging.\n\n\n      if (this.startupPeriod) {\n        // Drop out of startup period if\n        // - estimate is above default\n        // - get packet loss and have a valid estimate\n        // - startup period has expired and rate is not still increasing\n        if (this.downlinkStats.bandwidthEstimateKbps > VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS || this.downlinkStats.packetsLost > 0 || now - this.timeFirstEstimate > VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS && this.downlinkStats.bandwidthEstimateKbps <= this.prevDownlinkStats.bandwidthEstimateKbps) {\n          this.startupPeriod = false;\n          this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      } // If we are in the startup period and we haven't detected any packet loss, then\n      // keep it at the default to let the estimation get to a steady state\n\n\n      if (this.startupPeriod) {\n        targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n      }\n    } else {\n      if (this.timeFirstEstimate === 0) {\n        targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.prevTargetRateKbps;\n      }\n    }\n\n    targetBitrate = Math.max(minTargetDownlinkBitrate, targetBitrate); // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n    // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n    // a precursor to packet loss.  We have seen too many false positives on this, so we\n    // will ignore largish drops in the estimate if there is no packet loss\n\n    if (!this.startupPeriod && (this.usingPrevTargetRate && this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps || this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps * (100 - VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) / 100 || this.downlinkStats.bandwidthEstimateKbps < this.downlinkStats.usedBandwidthKbps * VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT / 100) && this.downlinkStats.packetsLost === 0) {\n      // Set target to be the same as last\n      this.logger.debug(function () {\n        return 'bwe: ValidateRate: Using Previous rate ' + _this.prevTargetRateKbps;\n      });\n      this.usingPrevTargetRate = true;\n      targetBitrate = this.prevTargetRateKbps;\n    } else {\n      this.usingPrevTargetRate = false;\n    }\n\n    return targetBitrate;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.setProbeState = function (newState) {\n    if (this.rateProbeState === newState) return;\n    var now = Date.now();\n\n    switch (newState) {\n      case \"Not Probing\"\n      /* kNotProbing */\n      :\n        this.timeProbePendingStart = 0;\n        break;\n\n      case \"Probe Pending\"\n      /* kProbePending */\n      :\n        if (this.timeLastProbe === 0 || now - this.timeLastProbe > VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE) {\n          this.timeProbePendingStart = now;\n        } else {\n          // Too soon to do a probe again\n          return false;\n        }\n\n        break;\n\n      case \"Probing\"\n      /* kProbing */\n      :\n        if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n          this.timeLastProbe = now;\n          this.preProbeReceiveSet = this.subscribedReceiveSet; // Increase the time allowed until the next probe\n\n          this.timeBeforeAllowProbeMs = Math.min(this.timeBeforeAllowProbeMs * 2, VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE);\n        } else {\n          // Too soon to do probe\n          return false;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n    this.rateProbeState = newState;\n    return true;\n  }; // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n  // Return the added amount of bandwidth\n\n\n  VideoAdaptiveProbePolicy.prototype.upgradeToStream = function (chosenStreams, upgradeStream) {\n    for (var i = 0; i < chosenStreams.length; i++) {\n      if (chosenStreams[i].groupId === upgradeStream.groupId) {\n        var diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n        this.logger.info('bwe: upgradeStream from ' + JSON.stringify(chosenStreams[i]) + ' to ' + JSON.stringify(upgradeStream));\n        this.lastUpgradeRateKbps = diffRate;\n        chosenStreams[i] = upgradeStream;\n        return diffRate;\n      }\n    } // We are adding a stream and not upgrading.\n\n\n    chosenStreams.push(upgradeStream);\n    this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n    return this.lastUpgradeRateKbps;\n  }; // Do specific behavior while we are currently in probing state and metrics\n  // indicate environment is still valid to do probing.\n  // Return true if the caller should not change from the previous subscriptions.\n\n\n  VideoAdaptiveProbePolicy.prototype.handleProbe = function (chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos) {\n    var e_6, _a;\n\n    if (this.rateProbeState !== \"Probing\"\n    /* kProbing */\n    ) {\n        return 0\n        /* kNewOptimal */\n        ;\n      } // Don't allow probe to happen indefinitely\n\n\n    if (Date.now() - this.timeLastProbe > VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n      this.logger.info(\"bwe: Canceling probe due to timeout\");\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      return 0\n      /* kNewOptimal */\n      ;\n    }\n\n    if (this.downlinkStats.packetsLost > 0) {\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE * 3;\n      return 2\n      /* kPreProbe */\n      ;\n    }\n\n    var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n\n    if (this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) || targetDownlinkBitrate > subscribedRate) {\n      var avgRate = 0;\n\n      try {\n        for (var chosenStreams_2 = __values(chosenStreams), chosenStreams_2_1 = chosenStreams_2.next(); !chosenStreams_2_1.done; chosenStreams_2_1 = chosenStreams_2.next()) {\n          var chosenStream = chosenStreams_2_1.value;\n          avgRate += chosenStream.avgBitrateKbps;\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (chosenStreams_2_1 && !chosenStreams_2_1.done && (_a = chosenStreams_2.return)) _a.call(chosenStreams_2);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      if (targetDownlinkBitrate > avgRate) {\n        // If target bitrate can sustain probe rate, then probe was successful.\n        this.setProbeState(\"Not Probing\"\n        /* kNotProbing */\n        ); // Reset the time allowed between probes since this was successful\n\n        this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n        return 0\n        /* kNewOptimal */\n        ;\n      }\n    }\n\n    return 1\n    /* kPreviousOptimal */\n    ;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.maybeOverrideOrProbe = function (chosenStreams, pausedStreamIds, chosenTotalBitrate, targetDownlinkBitrate, deltaToNextUpgrade, upgradeStream) {\n    var sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds);\n    var useLastSubscriptions = 0\n    /* kNewOptimal */\n    ;\n    var now = Date.now(); // We want to minimize thrashing between between low res and high res of different\n    // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n    // and the number of streams and their max rates are the same, then reuse the previous subscription\n\n    var triggerPercent = targetDownlinkBitrate > VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS ? VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT : VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n    var minTargetBitrateDelta = targetDownlinkBitrate * triggerPercent / 100;\n\n    if (!sameSubscriptions && Math.abs(targetDownlinkBitrate - this.prevTargetRateKbps) < minTargetBitrateDelta) {\n      this.logger.info('bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' + JSON.stringify(this.subscribedReceiveSet) + \"}\");\n      useLastSubscriptions = 1\n      /* kPreviousOptimal */\n      ;\n    } // If there has been packet loss, then reset to no probing state\n\n\n    if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n      this.lastUpgradeRateKbps = 0;\n      return useLastSubscriptions;\n    }\n\n    if (sameSubscriptions || useLastSubscriptions) {\n      // If planned subscriptions are same as last, then either move to probe pending state\n      // or move to probing state if enough time has passed.\n      switch (this.rateProbeState) {\n        case \"Not Probing\"\n        /* kNotProbing */\n        :\n          this.setProbeState(\"Probe Pending\"\n          /* kProbePending */\n          );\n          break;\n\n        case \"Probe Pending\"\n        /* kProbePending */\n        :\n          if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n            if (this.setProbeState(\"Probing\"\n            /* kProbing */\n            )) {\n              this.timeBeforeAllowSubscribeMs = 800;\n              this.upgradeToStream(chosenStreams, upgradeStream);\n              useLastSubscriptions = 0\n              /* kNewOptimal */\n              ;\n            }\n          }\n\n          break;\n\n        default:\n          this.logger.info('bwe: MaybeOverrideOrProbe: Unhandled condition ' + this.rateProbeState);\n          break;\n      }\n    } else {\n      // At this point the current expectation is to subscribe for a new set of\n      // streams, and environment is not right for probing.  If target rate is within\n      // the threshold of doing an upgrade, then do it and if we are lucky will be the\n      // same set of streams as last and no new subscription will be done.\n      this.setProbeState(\"Not Probing\"\n      /* kNotProbing */\n      );\n\n      if (targetDownlinkBitrate + minTargetBitrateDelta > chosenTotalBitrate + deltaToNextUpgrade) {\n        this.logger.info('bwe: MaybeOverrideOrProbe: Upgrade since we are within threshold');\n        this.upgradeToStream(chosenStreams, upgradeStream);\n      }\n    }\n\n    return useLastSubscriptions;\n  }; // Utility function to find max rate of streams in current decision\n\n\n  VideoAdaptiveProbePolicy.prototype.calculateSubscribeRate = function (streams, streamSet) {\n    var e_7, _a;\n\n    var subscribeRate = 0;\n\n    var _loop_2 = function (index) {\n      var streamMatch = streams.find(function (stream) {\n        return stream.streamId === index;\n      });\n\n      if (streamMatch !== undefined) {\n        subscribeRate += streamMatch.maxBitrateKbps;\n      }\n    };\n\n    try {\n      for (var _b = __values(streamSet.array()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var index = _c.value;\n\n        _loop_2(index);\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    return subscribeRate;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.handlePausedStreams = function (streamSelectionSet, pausedStreamIds, remoteInfos) {\n    var remoteTiles = this.tileController.getAllRemoteVideoTiles();\n\n    for (var i = 0; i < remoteTiles.length; i++) {\n      var tile = remoteTiles[i];\n      var state = tile.state();\n\n      if (state.paused) {\n        var j = remoteInfos.length;\n\n        while (j--) {\n          if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n            this.logger.info('bwe: removed paused attendee ' + state.boundAttendeeId + ' streamId: ' + remoteInfos[j].streamId);\n            pausedStreamIds.add(remoteInfos[j].streamId); // Add the stream to the selection set to keep the tile around\n\n            if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n              streamSelectionSet.add(remoteInfos[j].streamId);\n            }\n\n            remoteInfos.splice(j, 1);\n          }\n        }\n      }\n    }\n  };\n\n  VideoAdaptiveProbePolicy.prototype.chooseContent = function (chosenStreams, remoteInfos) {\n    var e_8, _a;\n\n    var contentRate = 0;\n\n    try {\n      for (var remoteInfos_5 = __values(remoteInfos), remoteInfos_5_1 = remoteInfos_5.next(); !remoteInfos_5_1.done; remoteInfos_5_1 = remoteInfos_5.next()) {\n        var info = remoteInfos_5_1.value; // For now always subscribe to content even if higher bandwidth then target\n\n        if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality)) {\n          chosenStreams.push(info);\n          contentRate += info.avgBitrateKbps;\n        }\n      }\n    } catch (e_8_1) {\n      e_8 = {\n        error: e_8_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_5_1 && !remoteInfos_5_1.done && (_a = remoteInfos_5.return)) _a.call(remoteInfos_5);\n      } finally {\n        if (e_8) throw e_8.error;\n      }\n    }\n\n    return contentRate;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.availStreamsSameAsLast = function (remoteInfos) {\n    var e_9, _a;\n\n    if (this.prevRemoteInfos === undefined || remoteInfos.length !== this.prevRemoteInfos.length) {\n      return false;\n    }\n\n    var _loop_3 = function (info) {\n      var infoMatch = this_1.prevRemoteInfos.find(function (prevInfo) {\n        return prevInfo.groupId === info.groupId && prevInfo.streamId === info.streamId && prevInfo.maxBitrateKbps === info.maxBitrateKbps;\n      });\n\n      if (infoMatch === undefined) {\n        return {\n          value: false\n        };\n      }\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var remoteInfos_6 = __values(remoteInfos), remoteInfos_6_1 = remoteInfos_6.next(); !remoteInfos_6_1.done; remoteInfos_6_1 = remoteInfos_6.next()) {\n        var info = remoteInfos_6_1.value;\n\n        var state_1 = _loop_3(info);\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_6_1 && !remoteInfos_6_1.done && (_a = remoteInfos_6.return)) _a.call(remoteInfos_6);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n\n    return true;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.chosenStreamsSameAsLast = function (chosenStreams, pausedStreamIds) {\n    var e_10, _a;\n\n    var lastStreams = this.optimalReceiveSet.array();\n\n    var _loop_4 = function (id) {\n      if (!pausedStreamIds.contain(id) && chosenStreams.findIndex(function (chosenStream) {\n        return chosenStream.streamId === id;\n      }) === -1) {\n        return {\n          value: false\n        };\n      }\n    };\n\n    try {\n      for (var lastStreams_1 = __values(lastStreams), lastStreams_1_1 = lastStreams_1.next(); !lastStreams_1_1.done; lastStreams_1_1 = lastStreams_1.next()) {\n        var id = lastStreams_1_1.value;\n\n        var state_2 = _loop_4(id);\n\n        if (typeof state_2 === \"object\") return state_2.value;\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (lastStreams_1_1 && !lastStreams_1_1.done && (_a = lastStreams_1.return)) _a.call(lastStreams_1);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n\n    return true;\n  };\n\n  VideoAdaptiveProbePolicy.prototype.policyStateLogStr = function (remoteInfos, targetDownlinkBitrate) {\n    var e_11, _a;\n\n    var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n    var optimalReceiveSet = {\n      targetBitrate: targetDownlinkBitrate,\n      subscribedRate: subscribedRate,\n      probeState: this.rateProbeState,\n      startupPeriod: this.startupPeriod\n    }; // Reduced remote info logging:\n\n    var remoteInfoStr = \"remoteInfos: [\";\n\n    try {\n      for (var remoteInfos_7 = __values(remoteInfos), remoteInfos_7_1 = remoteInfos_7.next(); !remoteInfos_7_1.done; remoteInfos_7_1 = remoteInfos_7.next()) {\n        var info = remoteInfos_7_1.value;\n        remoteInfoStr += \"{grpId:\" + info.groupId + \" strId:\" + info.streamId + \" maxBr:\" + info.maxBitrateKbps + \" avgBr:\" + info.avgBitrateKbps + \"}, \";\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (remoteInfos_7_1 && !remoteInfos_7_1.done && (_a = remoteInfos_7.return)) _a.call(remoteInfos_7);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n\n    remoteInfoStr += \"]\";\n    var logString = \"bwe: optimalReceiveSet \" + JSON.stringify(optimalReceiveSet) + \"\\n\" + (\"bwe:   prev \" + JSON.stringify(this.prevDownlinkStats) + \"\\n\") + (\"bwe:   now  \" + JSON.stringify(this.downlinkStats) + \"\\n\") + (\"bwe:   \" + remoteInfoStr);\n    return logString;\n  };\n\n  VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS = 2800;\n  VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS = 6000;\n  VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\n  VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\n  VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS = 300;\n  VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE = 5000;\n  VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE = 2000;\n  VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE = 60000;\n  VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS = 60000;\n  return VideoAdaptiveProbePolicy;\n}();\n\nexports.default = VideoAdaptiveProbePolicy;","map":{"version":3,"sources":["../../src/videodownlinkbandwidthpolicy/VideoAdaptiveProbePolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ClientMetricReportDirection_1 = require(\"../clientmetricreport/ClientMetricReportDirection\");\nvar ContentShareConstants_1 = require(\"../contentsharecontroller/ContentShareConstants\");\nvar DefaultVideoStreamIdSet_1 = require(\"../videostreamidset/DefaultVideoStreamIdSet\");\nvar LinkMediaStats = /** @class */ (function () {\n    function LinkMediaStats() {\n        this.bandwidthEstimateKbps = 0;\n        this.usedBandwidthKbps = 0;\n        this.packetsLost = 0;\n        this.nackCount = 0;\n        this.rttMs = 0;\n    }\n    return LinkMediaStats;\n}());\nvar VideoAdaptiveProbePolicy = /** @class */ (function () {\n    function VideoAdaptiveProbePolicy(logger, tileController) {\n        this.logger = logger;\n        this.tileController = tileController;\n        this.reset();\n    }\n    VideoAdaptiveProbePolicy.prototype.reset = function () {\n        this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();\n        this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();\n        this.logCount = 0;\n        this.startupPeriod = true;\n        this.usingPrevTargetRate = false;\n        this.rateProbeState = \"Not Probing\" /* kNotProbing */;\n        this.timeFirstEstimate = 0;\n        this.lastUpgradeRateKbps = 0;\n        this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n        this.timeLastProbe = Date.now();\n        this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n        this.downlinkStats = new LinkMediaStats();\n        this.prevDownlinkStats = new LinkMediaStats();\n    };\n    VideoAdaptiveProbePolicy.prototype.updateIndex = function (videoIndex) {\n        this.videoIndex = videoIndex;\n    };\n    VideoAdaptiveProbePolicy.prototype.updateMetrics = function (clientMetricReport) {\n        if (this.videoIndex.allStreams().empty()) {\n            return;\n        }\n        this.prevDownlinkStats = this.downlinkStats;\n        this.downlinkStats = new LinkMediaStats();\n        var metricReport = clientMetricReport.getObservableMetrics();\n        this.downlinkStats.bandwidthEstimateKbps = metricReport.availableReceiveBandwidth / 1000;\n        for (var ssrcStr in clientMetricReport.streamMetricReports) {\n            var ssrc = Number(ssrcStr);\n            if (clientMetricReport.streamMetricReports[ssrc].direction === ClientMetricReportDirection_1.default.DOWNSTREAM) {\n                // Only use video stream metrics\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googNacksSent') &&\n                    clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n                    this.downlinkStats.nackCount += clientMetricReport.countPerSecond('googNacksSent', ssrc);\n                }\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('packetsLost') &&\n                    clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('googFrameRateReceived')) {\n                    this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n                }\n                if (clientMetricReport.streamMetricReports[ssrc].currentMetrics.hasOwnProperty('bytesReceived')) {\n                    this.downlinkStats.usedBandwidthKbps +=\n                        clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n                }\n            }\n        }\n    };\n    VideoAdaptiveProbePolicy.prototype.wantsResubscribe = function () {\n        this.optimalReceiveSet = this.calculateOptimalReceiveSet();\n        return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n    };\n    VideoAdaptiveProbePolicy.prototype.chooseSubscriptions = function () {\n        if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n            this.timeLastSubscribe = Date.now();\n        }\n        this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n        this.logger.info('bwe: chooseSubscriptions ' + JSON.stringify(this.subscribedReceiveSet));\n        return this.subscribedReceiveSet.clone();\n    };\n    VideoAdaptiveProbePolicy.prototype.calculateOptimalReceiveSet = function () {\n        var e_1, _a, e_2, _b, e_3, _c;\n        var streamSelectionSet = new DefaultVideoStreamIdSet_1.default();\n        var lastProbeState = this.rateProbeState;\n        var remoteInfos = this.videoIndex.remoteStreamDescriptions();\n        if (remoteInfos.length === 0) {\n            return streamSelectionSet;\n        }\n        var pausedStreamIds = new DefaultVideoStreamIdSet_1.default();\n        this.handlePausedStreams(streamSelectionSet, pausedStreamIds, remoteInfos);\n        var sameStreamChoices = this.availStreamsSameAsLast(remoteInfos);\n        // If no major changes then don't allow subscribes for the allowed amount of time\n        if (!this.startupPeriod &&\n            sameStreamChoices &&\n            Date.now() - this.timeLastSubscribe < this.timeBeforeAllowSubscribeMs) {\n            return this.optimalReceiveSet;\n        }\n        // reset time before allow subscribe to default\n        this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE;\n        var chosenStreams = [];\n        // Sort streams by bitrate asceending.\n        remoteInfos.sort(function (a, b) {\n            if (a.maxBitrateKbps === b.maxBitrateKbps) {\n                return a.streamId - b.streamId;\n            }\n            return a.maxBitrateKbps - b.maxBitrateKbps;\n        });\n        try {\n            // Convert 0 avg bitrates to max and handle special cases\n            for (var remoteInfos_1 = __values(remoteInfos), remoteInfos_1_1 = remoteInfos_1.next(); !remoteInfos_1_1.done; remoteInfos_1_1 = remoteInfos_1.next()) {\n                var info = remoteInfos_1_1.value;\n                if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n                    // Content can be a special case\n                    if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality) && info.maxBitrateKbps < 100) {\n                        info.maxBitrateKbps = info.avgBitrateKbps;\n                    }\n                    else {\n                        info.avgBitrateKbps = info.maxBitrateKbps;\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (remoteInfos_1_1 && !remoteInfos_1_1.done && (_a = remoteInfos_1.return)) _a.call(remoteInfos_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var targetDownlinkBitrate = this.determineTargetRate(remoteInfos);\n        var deltaToNextUpgrade = 0;\n        var chosenTotalBitrate = 0;\n        var upgradeStream;\n        // If screen share is available, then subscribe to that first before anything else\n        chosenTotalBitrate += this.chooseContent(chosenStreams, remoteInfos);\n        var _loop_1 = function (info) {\n            if (info.avgBitrateKbps === 0) {\n                return \"continue\";\n            }\n            if (chosenStreams.findIndex(function (stream) { return stream.groupId === info.groupId; }) === -1) {\n                if (chosenTotalBitrate + info.avgBitrateKbps <= targetDownlinkBitrate) {\n                    chosenStreams.push(info);\n                    chosenTotalBitrate += info.avgBitrateKbps;\n                }\n                else if (deltaToNextUpgrade === 0) {\n                    // Keep track of step to next upgrade\n                    deltaToNextUpgrade = info.avgBitrateKbps;\n                    upgradeStream = info;\n                }\n            }\n        };\n        try {\n            // Try to have at least one stream from every group first\n            // Since the streams are sorted this will pick the lowest bitrates first\n            for (var remoteInfos_2 = __values(remoteInfos), remoteInfos_2_1 = remoteInfos_2.next(); !remoteInfos_2_1.done; remoteInfos_2_1 = remoteInfos_2.next()) {\n                var info = remoteInfos_2_1.value;\n                _loop_1(info);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (remoteInfos_2_1 && !remoteInfos_2_1.done && (_b = remoteInfos_2.return)) _b.call(remoteInfos_2);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        // Look for upgrades until we run out of bandwidth\n        var lookForUpgrades = true;\n        while (lookForUpgrades) {\n            // We will set this to true if we find any new upgrades during the loop over the\n            // chosen streams (i.e. when we do a full loop without an upgrade we will give up)\n            lookForUpgrades = false;\n            chosenStreams.forEach(function (chosenStream, index) {\n                var e_4, _a;\n                try {\n                    for (var remoteInfos_3 = (e_4 = void 0, __values(remoteInfos)), remoteInfos_3_1 = remoteInfos_3.next(); !remoteInfos_3_1.done; remoteInfos_3_1 = remoteInfos_3.next()) {\n                        var info = remoteInfos_3_1.value;\n                        if (info.groupId === chosenStream.groupId &&\n                            info.streamId !== chosenStream.streamId &&\n                            info.avgBitrateKbps > chosenStream.avgBitrateKbps) {\n                            var increaseKbps = info.avgBitrateKbps - chosenStream.avgBitrateKbps;\n                            if (chosenTotalBitrate + increaseKbps <= targetDownlinkBitrate) {\n                                chosenTotalBitrate += increaseKbps;\n                                chosenStreams[index] = info;\n                                lookForUpgrades = true;\n                            }\n                            else if (deltaToNextUpgrade === 0) {\n                                // Keep track of step to next upgrade\n                                deltaToNextUpgrade = increaseKbps;\n                                upgradeStream = info;\n                            }\n                        }\n                    }\n                }\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                finally {\n                    try {\n                        if (remoteInfos_3_1 && !remoteInfos_3_1.done && (_a = remoteInfos_3.return)) _a.call(remoteInfos_3);\n                    }\n                    finally { if (e_4) throw e_4.error; }\n                }\n            });\n        }\n        var subscriptionChoice = 0 /* kNewOptimal */;\n        // Look for probing or override opportunities\n        if (!this.startupPeriod && sameStreamChoices && deltaToNextUpgrade !== 0) {\n            if (this.rateProbeState === \"Probing\" /* kProbing */) {\n                subscriptionChoice = this.handleProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos);\n            }\n            else {\n                subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, pausedStreamIds, targetDownlinkBitrate, chosenTotalBitrate, deltaToNextUpgrade, upgradeStream);\n            }\n        }\n        else {\n            // If there was a change in streams to choose from, then cancel any probing or upgrades\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.lastUpgradeRateKbps = 0;\n        }\n        var decisionLogStr = this.policyStateLogStr(remoteInfos, targetDownlinkBitrate);\n        if (this.logCount % 15 === 0 || this.rateProbeState !== lastProbeState) {\n            this.logger.info(decisionLogStr);\n            this.logCount = 0;\n            decisionLogStr = '';\n        }\n        this.logCount++;\n        this.prevTargetRateKbps = targetDownlinkBitrate;\n        this.prevRemoteInfos = remoteInfos;\n        if (subscriptionChoice === 1 /* kPreviousOptimal */) {\n            this.logger.info('bwe: keepSameSubscriptions');\n            if (decisionLogStr.length > 0) {\n                this.logger.info(decisionLogStr);\n            }\n            return this.optimalReceiveSet;\n        }\n        else if (subscriptionChoice === 2 /* kPreProbe */) {\n            var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.preProbeReceiveSet);\n            this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n            return this.preProbeReceiveSet;\n        }\n        try {\n            for (var chosenStreams_1 = __values(chosenStreams), chosenStreams_1_1 = chosenStreams_1.next(); !chosenStreams_1_1.done; chosenStreams_1_1 = chosenStreams_1.next()) {\n                var chosenStream = chosenStreams_1_1.value;\n                streamSelectionSet.add(chosenStream.streamId);\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (chosenStreams_1_1 && !chosenStreams_1_1.done && (_c = chosenStreams_1.return)) _c.call(chosenStreams_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n            if (decisionLogStr.length > 0) {\n                this.logger.info(decisionLogStr);\n            }\n            var subscribedRate = this.calculateSubscribeRate(remoteInfos, streamSelectionSet);\n            this.logger.info(\"bwe: new streamSelection: \" + JSON.stringify(streamSelectionSet) + \" subscribedRate:\" + subscribedRate);\n        }\n        return streamSelectionSet;\n    };\n    VideoAdaptiveProbePolicy.prototype.determineTargetRate = function (remoteInfos) {\n        var e_5, _a;\n        var _this = this;\n        var targetBitrate = 0;\n        // Estimated downlink bandwidth from WebRTC is dependent on actually receiving data, so if it ever got driven below the bitrate of the lowest\n        // stream (a simulcast stream), and it stops receiving, it will get stuck never being able to resubscribe (as is implemented).\n        var minTargetDownlinkBitrate = Number.MAX_VALUE;\n        try {\n            for (var remoteInfos_4 = __values(remoteInfos), remoteInfos_4_1 = remoteInfos_4.next(); !remoteInfos_4_1.done; remoteInfos_4_1 = remoteInfos_4.next()) {\n                var info = remoteInfos_4_1.value;\n                if (info.avgBitrateKbps !== 0 && info.avgBitrateKbps < minTargetDownlinkBitrate) {\n                    minTargetDownlinkBitrate = info.avgBitrateKbps;\n                }\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (remoteInfos_4_1 && !remoteInfos_4_1.done && (_a = remoteInfos_4.return)) _a.call(remoteInfos_4);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        var now = Date.now();\n        // Startup phase handling.  During this period the estimate can be 0 or\n        // could still be slowly hunting for a steady state.  This startup ramp up\n        // can cause a series of subscribes which can be distracting. During this\n        // time just use our configured default value\n        if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n            if (this.timeFirstEstimate === 0) {\n                this.timeFirstEstimate = now;\n            }\n            // handle startup state where estimator is still converging.\n            if (this.startupPeriod) {\n                // Drop out of startup period if\n                // - estimate is above default\n                // - get packet loss and have a valid estimate\n                // - startup period has expired and rate is not still increasing\n                if (this.downlinkStats.bandwidthEstimateKbps >\n                    VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS ||\n                    this.downlinkStats.packetsLost > 0 ||\n                    (now - this.timeFirstEstimate > VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS &&\n                        this.downlinkStats.bandwidthEstimateKbps <=\n                            this.prevDownlinkStats.bandwidthEstimateKbps)) {\n                    this.startupPeriod = false;\n                    this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n                }\n            }\n            // If we are in the startup period and we haven't detected any packet loss, then\n            // keep it at the default to let the estimation get to a steady state\n            if (this.startupPeriod) {\n                targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n            }\n            else {\n                targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n            }\n        }\n        else {\n            if (this.timeFirstEstimate === 0) {\n                targetBitrate = VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS;\n            }\n            else {\n                targetBitrate = this.prevTargetRateKbps;\n            }\n        }\n        targetBitrate = Math.max(minTargetDownlinkBitrate, targetBitrate);\n        // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n        // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n        // a precursor to packet loss.  We have seen too many false positives on this, so we\n        // will ignore largish drops in the estimate if there is no packet loss\n        if (!this.startupPeriod &&\n            ((this.usingPrevTargetRate &&\n                this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps) ||\n                this.downlinkStats.bandwidthEstimateKbps <\n                    (this.prevTargetRateKbps *\n                        (100 - VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT)) /\n                        100 ||\n                this.downlinkStats.bandwidthEstimateKbps <\n                    (this.downlinkStats.usedBandwidthKbps *\n                        VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) /\n                        100) &&\n            this.downlinkStats.packetsLost === 0) {\n            // Set target to be the same as last\n            this.logger.debug(function () {\n                return 'bwe: ValidateRate: Using Previous rate ' + _this.prevTargetRateKbps;\n            });\n            this.usingPrevTargetRate = true;\n            targetBitrate = this.prevTargetRateKbps;\n        }\n        else {\n            this.usingPrevTargetRate = false;\n        }\n        return targetBitrate;\n    };\n    VideoAdaptiveProbePolicy.prototype.setProbeState = function (newState) {\n        if (this.rateProbeState === newState)\n            return;\n        var now = Date.now();\n        switch (newState) {\n            case \"Not Probing\" /* kNotProbing */:\n                this.timeProbePendingStart = 0;\n                break;\n            case \"Probe Pending\" /* kProbePending */:\n                if (this.timeLastProbe === 0 ||\n                    now - this.timeLastProbe > VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE) {\n                    this.timeProbePendingStart = now;\n                }\n                else {\n                    // Too soon to do a probe again\n                    return false;\n                }\n                break;\n            case \"Probing\" /* kProbing */:\n                if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n                    this.timeLastProbe = now;\n                    this.preProbeReceiveSet = this.subscribedReceiveSet;\n                    // Increase the time allowed until the next probe\n                    this.timeBeforeAllowProbeMs = Math.min(this.timeBeforeAllowProbeMs * 2, VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE);\n                }\n                else {\n                    // Too soon to do probe\n                    return false;\n                }\n                break;\n            default:\n                break;\n        }\n        this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n        this.rateProbeState = newState;\n        return true;\n    };\n    // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n    // Return the added amount of bandwidth\n    VideoAdaptiveProbePolicy.prototype.upgradeToStream = function (chosenStreams, upgradeStream) {\n        for (var i = 0; i < chosenStreams.length; i++) {\n            if (chosenStreams[i].groupId === upgradeStream.groupId) {\n                var diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n                this.logger.info('bwe: upgradeStream from ' +\n                    JSON.stringify(chosenStreams[i]) +\n                    ' to ' +\n                    JSON.stringify(upgradeStream));\n                this.lastUpgradeRateKbps = diffRate;\n                chosenStreams[i] = upgradeStream;\n                return diffRate;\n            }\n        }\n        // We are adding a stream and not upgrading.\n        chosenStreams.push(upgradeStream);\n        this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n        return this.lastUpgradeRateKbps;\n    };\n    // Do specific behavior while we are currently in probing state and metrics\n    // indicate environment is still valid to do probing.\n    // Return true if the caller should not change from the previous subscriptions.\n    VideoAdaptiveProbePolicy.prototype.handleProbe = function (chosenStreams, pausedStreamIds, targetDownlinkBitrate, remoteInfos) {\n        var e_6, _a;\n        if (this.rateProbeState !== \"Probing\" /* kProbing */) {\n            return 0 /* kNewOptimal */;\n        }\n        // Don't allow probe to happen indefinitely\n        if (Date.now() - this.timeLastProbe > VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n            this.logger.info(\"bwe: Canceling probe due to timeout\");\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            return 0 /* kNewOptimal */;\n        }\n        if (this.downlinkStats.packetsLost > 0) {\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.timeBeforeAllowSubscribeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE * 3;\n            return 2 /* kPreProbe */;\n        }\n        var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n        if (this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds) ||\n            targetDownlinkBitrate > subscribedRate) {\n            var avgRate = 0;\n            try {\n                for (var chosenStreams_2 = __values(chosenStreams), chosenStreams_2_1 = chosenStreams_2.next(); !chosenStreams_2_1.done; chosenStreams_2_1 = chosenStreams_2.next()) {\n                    var chosenStream = chosenStreams_2_1.value;\n                    avgRate += chosenStream.avgBitrateKbps;\n                }\n            }\n            catch (e_6_1) { e_6 = { error: e_6_1 }; }\n            finally {\n                try {\n                    if (chosenStreams_2_1 && !chosenStreams_2_1.done && (_a = chosenStreams_2.return)) _a.call(chosenStreams_2);\n                }\n                finally { if (e_6) throw e_6.error; }\n            }\n            if (targetDownlinkBitrate > avgRate) {\n                // If target bitrate can sustain probe rate, then probe was successful.\n                this.setProbeState(\"Not Probing\" /* kNotProbing */);\n                // Reset the time allowed between probes since this was successful\n                this.timeBeforeAllowProbeMs = VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE;\n                return 0 /* kNewOptimal */;\n            }\n        }\n        return 1 /* kPreviousOptimal */;\n    };\n    VideoAdaptiveProbePolicy.prototype.maybeOverrideOrProbe = function (chosenStreams, pausedStreamIds, chosenTotalBitrate, targetDownlinkBitrate, deltaToNextUpgrade, upgradeStream) {\n        var sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams, pausedStreamIds);\n        var useLastSubscriptions = 0 /* kNewOptimal */;\n        var now = Date.now();\n        // We want to minimize thrashing between between low res and high res of different\n        // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n        // and the number of streams and their max rates are the same, then reuse the previous subscription\n        var triggerPercent = targetDownlinkBitrate > VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS\n            ? VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT\n            : VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n        var minTargetBitrateDelta = (targetDownlinkBitrate * triggerPercent) / 100;\n        if (!sameSubscriptions &&\n            Math.abs(targetDownlinkBitrate - this.prevTargetRateKbps) < minTargetBitrateDelta) {\n            this.logger.info('bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' +\n                JSON.stringify(this.subscribedReceiveSet) +\n                \"}\");\n            useLastSubscriptions = 1 /* kPreviousOptimal */;\n        }\n        // If there has been packet loss, then reset to no probing state\n        if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            this.lastUpgradeRateKbps = 0;\n            return useLastSubscriptions;\n        }\n        if (sameSubscriptions || useLastSubscriptions) {\n            // If planned subscriptions are same as last, then either move to probe pending state\n            // or move to probing state if enough time has passed.\n            switch (this.rateProbeState) {\n                case \"Not Probing\" /* kNotProbing */:\n                    this.setProbeState(\"Probe Pending\" /* kProbePending */);\n                    break;\n                case \"Probe Pending\" /* kProbePending */:\n                    if (now - this.timeProbePendingStart > this.timeBeforeAllowProbeMs) {\n                        if (this.setProbeState(\"Probing\" /* kProbing */)) {\n                            this.timeBeforeAllowSubscribeMs = 800;\n                            this.upgradeToStream(chosenStreams, upgradeStream);\n                            useLastSubscriptions = 0 /* kNewOptimal */;\n                        }\n                    }\n                    break;\n                default:\n                    this.logger.info('bwe: MaybeOverrideOrProbe: Unhandled condition ' + this.rateProbeState);\n                    break;\n            }\n        }\n        else {\n            // At this point the current expectation is to subscribe for a new set of\n            // streams, and environment is not right for probing.  If target rate is within\n            // the threshold of doing an upgrade, then do it and if we are lucky will be the\n            // same set of streams as last and no new subscription will be done.\n            this.setProbeState(\"Not Probing\" /* kNotProbing */);\n            if (targetDownlinkBitrate + minTargetBitrateDelta > chosenTotalBitrate + deltaToNextUpgrade) {\n                this.logger.info('bwe: MaybeOverrideOrProbe: Upgrade since we are within threshold');\n                this.upgradeToStream(chosenStreams, upgradeStream);\n            }\n        }\n        return useLastSubscriptions;\n    };\n    // Utility function to find max rate of streams in current decision\n    VideoAdaptiveProbePolicy.prototype.calculateSubscribeRate = function (streams, streamSet) {\n        var e_7, _a;\n        var subscribeRate = 0;\n        var _loop_2 = function (index) {\n            var streamMatch = streams.find(function (stream) { return stream.streamId === index; });\n            if (streamMatch !== undefined) {\n                subscribeRate += streamMatch.maxBitrateKbps;\n            }\n        };\n        try {\n            for (var _b = __values(streamSet.array()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var index = _c.value;\n                _loop_2(index);\n            }\n        }\n        catch (e_7_1) { e_7 = { error: e_7_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_7) throw e_7.error; }\n        }\n        return subscribeRate;\n    };\n    VideoAdaptiveProbePolicy.prototype.handlePausedStreams = function (streamSelectionSet, pausedStreamIds, remoteInfos) {\n        var remoteTiles = this.tileController.getAllRemoteVideoTiles();\n        for (var i = 0; i < remoteTiles.length; i++) {\n            var tile = remoteTiles[i];\n            var state = tile.state();\n            if (state.paused) {\n                var j = remoteInfos.length;\n                while (j--) {\n                    if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n                        this.logger.info('bwe: removed paused attendee ' +\n                            state.boundAttendeeId +\n                            ' streamId: ' +\n                            remoteInfos[j].streamId);\n                        pausedStreamIds.add(remoteInfos[j].streamId);\n                        // Add the stream to the selection set to keep the tile around\n                        if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n                            streamSelectionSet.add(remoteInfos[j].streamId);\n                        }\n                        remoteInfos.splice(j, 1);\n                    }\n                }\n            }\n        }\n    };\n    VideoAdaptiveProbePolicy.prototype.chooseContent = function (chosenStreams, remoteInfos) {\n        var e_8, _a;\n        var contentRate = 0;\n        try {\n            for (var remoteInfos_5 = __values(remoteInfos), remoteInfos_5_1 = remoteInfos_5.next(); !remoteInfos_5_1.done; remoteInfos_5_1 = remoteInfos_5.next()) {\n                var info = remoteInfos_5_1.value;\n                // For now always subscribe to content even if higher bandwidth then target\n                if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality)) {\n                    chosenStreams.push(info);\n                    contentRate += info.avgBitrateKbps;\n                }\n            }\n        }\n        catch (e_8_1) { e_8 = { error: e_8_1 }; }\n        finally {\n            try {\n                if (remoteInfos_5_1 && !remoteInfos_5_1.done && (_a = remoteInfos_5.return)) _a.call(remoteInfos_5);\n            }\n            finally { if (e_8) throw e_8.error; }\n        }\n        return contentRate;\n    };\n    VideoAdaptiveProbePolicy.prototype.availStreamsSameAsLast = function (remoteInfos) {\n        var e_9, _a;\n        if (this.prevRemoteInfos === undefined || remoteInfos.length !== this.prevRemoteInfos.length) {\n            return false;\n        }\n        var _loop_3 = function (info) {\n            var infoMatch = this_1.prevRemoteInfos.find(function (prevInfo) {\n                return prevInfo.groupId === info.groupId &&\n                    prevInfo.streamId === info.streamId &&\n                    prevInfo.maxBitrateKbps === info.maxBitrateKbps;\n            });\n            if (infoMatch === undefined) {\n                return { value: false };\n            }\n        };\n        var this_1 = this;\n        try {\n            for (var remoteInfos_6 = __values(remoteInfos), remoteInfos_6_1 = remoteInfos_6.next(); !remoteInfos_6_1.done; remoteInfos_6_1 = remoteInfos_6.next()) {\n                var info = remoteInfos_6_1.value;\n                var state_1 = _loop_3(info);\n                if (typeof state_1 === \"object\")\n                    return state_1.value;\n            }\n        }\n        catch (e_9_1) { e_9 = { error: e_9_1 }; }\n        finally {\n            try {\n                if (remoteInfos_6_1 && !remoteInfos_6_1.done && (_a = remoteInfos_6.return)) _a.call(remoteInfos_6);\n            }\n            finally { if (e_9) throw e_9.error; }\n        }\n        return true;\n    };\n    VideoAdaptiveProbePolicy.prototype.chosenStreamsSameAsLast = function (chosenStreams, pausedStreamIds) {\n        var e_10, _a;\n        var lastStreams = this.optimalReceiveSet.array();\n        var _loop_4 = function (id) {\n            if (!pausedStreamIds.contain(id) &&\n                chosenStreams.findIndex(function (chosenStream) { return chosenStream.streamId === id; }) === -1) {\n                return { value: false };\n            }\n        };\n        try {\n            for (var lastStreams_1 = __values(lastStreams), lastStreams_1_1 = lastStreams_1.next(); !lastStreams_1_1.done; lastStreams_1_1 = lastStreams_1.next()) {\n                var id = lastStreams_1_1.value;\n                var state_2 = _loop_4(id);\n                if (typeof state_2 === \"object\")\n                    return state_2.value;\n            }\n        }\n        catch (e_10_1) { e_10 = { error: e_10_1 }; }\n        finally {\n            try {\n                if (lastStreams_1_1 && !lastStreams_1_1.done && (_a = lastStreams_1.return)) _a.call(lastStreams_1);\n            }\n            finally { if (e_10) throw e_10.error; }\n        }\n        return true;\n    };\n    VideoAdaptiveProbePolicy.prototype.policyStateLogStr = function (remoteInfos, targetDownlinkBitrate) {\n        var e_11, _a;\n        var subscribedRate = this.calculateSubscribeRate(remoteInfos, this.optimalReceiveSet);\n        var optimalReceiveSet = {\n            targetBitrate: targetDownlinkBitrate,\n            subscribedRate: subscribedRate,\n            probeState: this.rateProbeState,\n            startupPeriod: this.startupPeriod,\n        };\n        // Reduced remote info logging:\n        var remoteInfoStr = \"remoteInfos: [\";\n        try {\n            for (var remoteInfos_7 = __values(remoteInfos), remoteInfos_7_1 = remoteInfos_7.next(); !remoteInfos_7_1.done; remoteInfos_7_1 = remoteInfos_7.next()) {\n                var info = remoteInfos_7_1.value;\n                remoteInfoStr += \"{grpId:\" + info.groupId + \" strId:\" + info.streamId + \" maxBr:\" + info.maxBitrateKbps + \" avgBr:\" + info.avgBitrateKbps + \"}, \";\n            }\n        }\n        catch (e_11_1) { e_11 = { error: e_11_1 }; }\n        finally {\n            try {\n                if (remoteInfos_7_1 && !remoteInfos_7_1.done && (_a = remoteInfos_7.return)) _a.call(remoteInfos_7);\n            }\n            finally { if (e_11) throw e_11.error; }\n        }\n        remoteInfoStr += \"]\";\n        var logString = \"bwe: optimalReceiveSet \" + JSON.stringify(optimalReceiveSet) + \"\\n\" +\n            (\"bwe:   prev \" + JSON.stringify(this.prevDownlinkStats) + \"\\n\") +\n            (\"bwe:   now  \" + JSON.stringify(this.downlinkStats) + \"\\n\") +\n            (\"bwe:   \" + remoteInfoStr);\n        return logString;\n    };\n    VideoAdaptiveProbePolicy.DEFAULT_BANDWIDTH_KBPS = 2800;\n    VideoAdaptiveProbePolicy.STARTUP_PERIOD_MS = 6000;\n    VideoAdaptiveProbePolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\n    VideoAdaptiveProbePolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\n    VideoAdaptiveProbePolicy.LOW_BITRATE_THRESHOLD_KBPS = 300;\n    VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_PROBE = 5000;\n    VideoAdaptiveProbePolicy.MIN_TIME_BETWEEN_SUBSCRIBE = 2000;\n    VideoAdaptiveProbePolicy.MAX_HOLD_MS_BEFORE_PROBE = 60000;\n    VideoAdaptiveProbePolicy.MAX_ALLOWED_PROBE_TIME_MS = 60000;\n    return VideoAdaptiveProbePolicy;\n}());\nexports.default = VideoAdaptiveProbePolicy;\n//# sourceMappingURL=VideoAdaptiveProbePolicy.js.map"]},"metadata":{},"sourceType":"script"}